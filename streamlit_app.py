import os
os.environ["STREAMLIT_WATCHER_IGNORE_MODULES"] = "torch"
import streamlit as st
import os
import os
import csv
USER_INPUT_LOG = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'user_input_log.csv')
from agents.farmer_advisor import FarmerAdvisor
from agents.market_researcher import MarketResearcher
from agents.weather_module import WeatherModule
from agents.agri_expert import AgriculturalExpert
from memory.memory_manager import MemoryManager
import numpy as np
from PIL import Image
import io
import pandas as pd
import datetime
import zipfile
import glob
import random
from image_classifier import ImageClassifier
from nlp_models import NLPModels
from utils.data_loader import get_geolocation  # <-- ADD THIS
import streamlit as st
import folium
from streamlit_folium import st_folium
import json
import os
import matplotlib.pyplot as plt
from collections import Counter
from datetime import datetime, date
import csv
import getpass
import getpass
from datetime import datetime
import streamlit_geolocation

USER_INPUT_LOG = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'user_input_log.csv')

def log_user_input(page, category, data):
    user_id = st.session_state.get('user_id', getpass.getuser())
    login_name = st.session_state.get('username', '')
    timestamp = datetime.utcnow().isoformat()
    row = {
        'timestamp': timestamp,
        'user_id': user_id,
        'login_name': login_name,
        'page': page,
        'category': category,
        'data': data
    }
    file_exists = os.path.isfile(USER_INPUT_LOG)
    with open(USER_INPUT_LOG, 'a', newline='', encoding='utf-8') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=['timestamp','user_id','login_name','page','category','data'])
        if not file_exists:
            writer.writeheader()
        writer.writerow(row)

# --- Translation dictionary ---
TRANSLATIONS = {
    'en': {
        'app_title': "üåæ KrishiSakhi: AI-Driven Farming Assistant üåæ",
        'home': "Home",
        'recommendations': "Get Recommendations",
        'diagnosis': "AI Disease Diagnosis",
        'validation': "Farmer Validation",
        'language': "Language",
        'select_language': "Select Language",
        'weather': "Weather Forecast",
        'input_options': "Input Options",
        'image_input': "Upload Image",
        'voice_input': "Voice Input",
        'text_input': "Text Input",
        'submit': "Submit",
        'severity': "Disease Severity Estimation",
        'correction': "Farmer Correction Workflow",
        'enter_farm_data': "Enter Farm Data",
        'farm_id': "Farm ID",
        'soil_ph': "Soil pH value",
        'soil_moisture': "Soil Moisture (%)",
        'temperature': "Temperature (¬∞C)",
        'rainfall': "Rainfall (mm)",
        'crop_type': "Crop Type",
        'fertilizer_usage': "Fertilizer Usage (kg)",
        'pesticide_usage': "Pesticide Usage (kg)",
        'crop_yield': "Crop Yield (ton)",
        'sustainability_score': "Sustainability Score",
        'select_crop': "Select current crop for market/weather/sustainability advice",
        'get_recommendations': "Get Recommendations",
        'soil_recommendations': "üßæ Soil Recommendations",
        'market_trends': "üìà Market Trends",
        'weather_forecast': "üå§Ô∏è Weather Forecast",
        'sustainable_practices': "üå± Sustainable Practices",
        'ai_diagnosis': "AI Diagnosis Result",
        'severity_result': "Estimated Severity",
        'validation_prompt': "Is the diagnosis correct?",
        'correction_prompt': "Please provide the correct diagnosis:",
        'thank_you': "Thank you for your feedback!",
        'back_home': "Back to Home",
        'growth_diary': 'Growth Diary',
        'add_entry': 'Add New Entry',
        'diary_log': 'Diary Log',
        'crop': 'Crop',
        'notes': 'Notes',
        'save_entry': 'Save Entry',
        'entry_saved': 'Entry saved!',
        'knowledge_sharing': 'Knowledge Sharing',
        'start_discussion': 'Start a New Discussion',
        'all_discussions': 'All Discussions',
        'post_thread': 'Post Thread',
        'reply': 'Reply',
        'thread_posted': 'Thread posted!',
        'reply_posted': 'Reply posted!',
        'soil_health': 'Soil Health Scanning',
        'add_soil_test': 'Add New Soil Test',
        'soil_test_log': 'Soil Test Log',
        'save_soil_test': 'Save Soil Test',
        'soil_test_saved': 'Soil test saved!',
        'heatmaps': 'Live Agri Heatmaps & Outbreak Visualization',
        'outbreak_map': 'Outbreak Map',
        'no_geo_reports': 'No geo-tagged reports available.',
        'report_outbreak': 'Report New Outbreak',
        'submit_outbreak': 'Submit Outbreak Report',
        'outbreak_reported': 'Outbreak reported!',
        'export_info': 'Export all anonymized data for research, startups, and policy teams.',
        'create_export_zip': 'Create Export ZIP',
        'export_created': 'Export ZIP created!',
        'download_corpus_zip': 'Download Corpus ZIP',
        'khet_market': 'Khet Market',
        'market_home': 'Home',
        'market_login': 'Login',
        'market_register': 'Register',
        'market_buyorsell': 'BuyOrSell',
        'market_buy': 'Buy',
        'market_checkout': 'Checkout',
        'market_payment': 'Payment',
        'market_orders': 'Orders',
        'market_sell': 'Sell',
        'market_selling_item': 'Selling Item',
        'login_username': 'Username',
        'login_password': 'Password',
        'login_btn': 'Login',
        'register_fullname': 'Full Name',
        'register_email': 'Email',
        'register_phone': 'Phone',
        'register_username': 'Username',
        'register_password': 'Password',
        'register_confirmpw': 'Confirm Password',
        'register_btn': 'Register',
        'buyorsell_buy': 'Go to Buy',
        'buyorsell_sell': 'Go to Sell',
        'payment_card': 'Card Number',
        'payment_expiry': 'Expiry Date',
        'payment_cvv': 'CVV',
        'payment_btn': 'Pay',
        'sell_crop': 'Crop Name',
        'sell_qty': 'Quantity (kg)',
        'sell_price': 'Price (per kg, must be >= MSP)',
        'sell_img': 'Upload Crop Image',
        'sell_btn': 'List for Sale',
        'output': 'Output',
        'context': 'Enter context for Q&A',
        'enter_context': 'Please enter context for Q&A.',
        'agribot_title': "ü§ñ AgriBot - Your Futuristic Agricultural Assistant",
        'agribot_greeting': "Hello! I'm AgriBot. How can I assist you with your farm today?",
        'agribot_input_placeholder': "Type your message here...",
        'agribot_attach_image': "Attach image (optional)",
        'send': "Send",
        'show_history': "Show Conversation History",
        'you': "You",
        'agribot': "AgriBot",
        'analytics_dashboard': "üìä Analytics Dashboard",
        'analytics_total_questions': "Total AgriBot Questions Asked",
        'analytics_common_crops': "Most Common Crops Discussed",
        'analytics_disease_trends': "Disease Diagnosis Trends",
        'analytics_engagement': "User Engagement Over Time",
        'analytics_pie_types': "Pie Chart of Question Types",
        'analytics_recent_log': "Recent Activity Log",
        'analytics_upload_csv': "Upload a CSV file for visualization",
        'analytics_no_data': "No chat data to display.",
        'analytics_no_conversations': "No conversation data found.",
        'analytics_no_keywords': "No crop keywords found in chats.",
        'analytics_no_disease': "No disease keywords found in chats.",
        'analytics_no_types': "No question type data found.",
        'analytics_info_upload': "If you want to visualize other CSV/statistics, upload them below:",
    },
    'te': {
        'app_title': "üåæ KrishiSakhi: ‡∞è‡∞ê ‡∞Ü‡∞ß‡∞æ‡∞∞‡∞ø‡∞§ ‡∞µ‡±ç‡∞Ø‡∞µ‡∞∏‡∞æ‡∞Ø ‡∞∏‡∞π‡∞æ‡∞Ø‡∞ï‡±Å‡∞°‡±Å üåæ",
        'home': "‡∞π‡±ã‡∞Æ‡±ç",
        'recommendations': "‡∞∏‡∞ø‡∞´‡∞æ‡∞∞‡±ç‡∞∏‡±Å‡∞≤‡±Å ‡∞™‡±ä‡∞Ç‡∞¶‡∞Ç‡∞°‡∞ø",
        'diagnosis': "‡∞è‡∞ê ‡∞µ‡±ç‡∞Ø‡∞æ‡∞ß‡∞ø ‡∞®‡∞ø‡∞∞‡±ç‡∞ß‡∞æ‡∞∞‡∞£",
        'validation': "‡∞∞‡±à‡∞§‡±Å ‡∞ß‡±É‡∞µ‡±Ä‡∞ï‡∞∞‡∞£",
        'language': "‡∞≠‡∞æ‡∞∑",
        'select_language': "‡∞≠‡∞æ‡∞∑‡∞®‡±Å ‡∞é‡∞Ç‡∞ö‡±Å‡∞ï‡±ã‡∞Ç‡∞°‡∞ø",
        'weather': "‡∞µ‡∞æ‡∞§‡∞æ‡∞µ‡∞∞‡∞£ ‡∞∏‡±Ç‡∞ö‡∞®",
        'input_options': "‡∞á‡∞®‡±ç‡∞™‡±Å‡∞ü‡±ç ‡∞é‡∞Ç‡∞™‡∞ø‡∞ï‡∞≤‡±Å",
        'image_input': "‡∞ö‡∞ø‡∞§‡±ç‡∞∞‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞Ö‡∞™‡±ç‚Äå‡∞≤‡±ã‡∞°‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø",
        'voice_input': "‡∞µ‡∞æ‡∞Ø‡∞ø‡∞∏‡±ç ‡∞á‡∞®‡±ç‡∞™‡±Å‡∞ü‡±ç",
        'text_input': "‡∞ü‡±Ü‡∞ï‡±ç‡∞∏‡±ç‡∞ü‡±ç ‡∞á‡∞®‡±ç‡∞™‡±Å‡∞ü‡±ç",
        'submit': "‡∞∏‡∞Æ‡∞∞‡±ç‡∞™‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø",
        'severity': "‡∞µ‡±ç‡∞Ø‡∞æ‡∞ß‡∞ø ‡∞§‡±Ä‡∞µ‡±ç‡∞∞‡∞§ ‡∞Ö‡∞Ç‡∞ö‡∞®‡∞æ",
        'correction': "‡∞∞‡±à‡∞§‡±Å ‡∞∏‡∞µ‡∞∞‡∞£ ‡∞µ‡∞∞‡±ç‡∞ï‡±ç‚Äå‡∞´‡±ç‡∞≤‡±ã",
        'enter_farm_data': "‡∞™‡∞Ç‡∞ü ‡∞°‡±á‡∞ü‡∞æ‡∞®‡±Å ‡∞®‡∞Æ‡±ã‡∞¶‡±Å ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø",
        'farm_id': "‡∞´‡∞æ‡∞∞‡±ç‡∞Æ‡±ç ‡∞ê‡∞°‡∞ø",
        'soil_ph': "‡∞Æ‡∞ü‡±ç‡∞ü‡∞ø ‡∞™‡∞ø‡∞π‡±Ü‡∞ö‡±ç ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ",
        'soil_moisture': "‡∞Æ‡∞ü‡±ç‡∞ü‡∞ø ‡∞§‡±á‡∞Æ (%)",
        'temperature': "‡∞â‡∞∑‡±ç‡∞£‡±ã‡∞ó‡±ç‡∞∞‡∞§ (¬∞C)",
        'rainfall': "‡∞µ‡∞∞‡±ç‡∞∑‡∞™‡∞æ‡∞§‡∞Ç (mm)",
        'crop_type': "‡∞™‡∞Ç‡∞ü ‡∞∞‡∞ï‡∞Ç",
        'fertilizer_usage': "‡∞é‡∞∞‡±Å‡∞µ‡±Å‡∞≤ ‡∞µ‡∞ø‡∞®‡∞ø‡∞Ø‡±ã‡∞ó‡∞Ç (kg)",
        'pesticide_usage': "‡∞™‡±Ü‡∞∏‡±ç‡∞ü‡∞ø‡∞∏‡±à‡∞°‡±ç ‡∞µ‡∞ø‡∞®‡∞ø‡∞Ø‡±ã‡∞ó‡∞Ç (kg)",
        'crop_yield': "‡∞™‡∞Ç‡∞ü ‡∞¶‡∞ø‡∞ó‡±Å‡∞¨‡∞°‡∞ø (‡∞ü‡∞®‡±ç‡∞®‡±Å‡∞≤‡±Å)",
        'sustainability_score': "‡∞∏‡∞∏‡±ç‡∞ü‡±à‡∞®‡∞¨‡∞ø‡∞≤‡∞ø‡∞ü‡±Ä ‡∞∏‡±ç‡∞ï‡±ã‡∞∞‡±ç",
        'select_crop': "‡∞Æ‡∞æ‡∞∞‡±ç‡∞ï‡±Ü‡∞ü‡±ç/‡∞µ‡∞æ‡∞§‡∞æ‡∞µ‡∞∞‡∞£/‡∞∏‡∞∏‡±ç‡∞ü‡±à‡∞®‡∞¨‡∞ø‡∞≤‡∞ø‡∞ü‡±Ä ‡∞∏‡∞≤‡∞π‡∞æ ‡∞ï‡±ã‡∞∏‡∞Ç ‡∞™‡±ç‡∞∞‡∞∏‡±ç‡∞§‡±Å‡∞§ ‡∞™‡∞Ç‡∞ü‡∞®‡±Å ‡∞é‡∞Ç‡∞ö‡±Å‡∞ï‡±ã‡∞Ç‡∞°‡∞ø",
        'get_recommendations': "‡∞∏‡∞ø‡∞´‡∞æ‡∞∞‡±ç‡∞∏‡±Å‡∞≤‡±Å ‡∞™‡±ä‡∞Ç‡∞¶‡∞Ç‡∞°‡∞ø",
        'soil_recommendations': "üßæ ‡∞Æ‡∞ü‡±ç‡∞ü‡∞ø ‡∞∏‡∞ø‡∞´‡∞æ‡∞∞‡±ç‡∞∏‡±Å‡∞≤‡±Å",
        'market_trends': "üìà ‡∞Æ‡∞æ‡∞∞‡±ç‡∞ï‡±Ü‡∞ü‡±ç ‡∞ü‡±ç‡∞∞‡±Ü‡∞Ç‡∞°‡±ç‡∞∏‡±ç",
        'weather_forecast': "üå§Ô∏è ‡∞µ‡∞æ‡∞§‡∞æ‡∞µ‡∞∞‡∞£ ‡∞∏‡±Ç‡∞ö‡∞®",
        'sustainable_practices': "üå± ‡∞∏‡∞∏‡±ç‡∞ü‡±à‡∞®‡∞¨‡±Å‡∞≤‡±ç ‡∞™‡∞¶‡±ç‡∞ß‡∞§‡±Å‡∞≤‡±Å",
        'ai_diagnosis': "‡∞è‡∞ê ‡∞®‡∞ø‡∞∞‡±ç‡∞ß‡∞æ‡∞∞‡∞£ ‡∞´‡∞≤‡∞ø‡∞§‡∞Ç",
        'severity_result': "‡∞Ö‡∞Ç‡∞ö‡∞®‡∞æ ‡∞µ‡±á‡∞∏‡∞ø‡∞® ‡∞§‡±Ä‡∞µ‡±ç‡∞∞‡∞§",
        'validation_prompt': "‡∞®‡∞ø‡∞∞‡±ç‡∞ß‡∞æ‡∞∞‡∞£ ‡∞∏‡∞∞‡±à‡∞Ç‡∞¶‡∞æ?",
        'correction_prompt': "‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞∏‡∞∞‡±à‡∞® ‡∞®‡∞ø‡∞∞‡±ç‡∞ß‡∞æ‡∞∞‡∞£‡∞®‡±Å ‡∞á‡∞µ‡±ç‡∞µ‡∞Ç‡∞°‡∞ø:",
        'thank_you': "‡∞Æ‡±Ä ‡∞Ö‡∞≠‡∞ø‡∞™‡±ç‡∞∞‡∞æ‡∞Ø‡∞æ‡∞®‡∞ø‡∞ï‡∞ø ‡∞ß‡∞®‡±ç‡∞Ø‡∞µ‡∞æ‡∞¶‡∞æ‡∞≤‡±Å!",
        'back_home': "‡∞π‡±ã‡∞Æ‡±ç‚Äå‡∞ï‡±Å ‡∞§‡∞ø‡∞∞‡∞ø‡∞ó‡∞ø ‡∞µ‡±Ü‡∞≥‡±ç‡∞≥‡∞Ç‡∞°‡∞ø",
        'growth_diary': "‡∞µ‡±É‡∞¶‡±ç‡∞ß‡∞ø ‡∞°‡±à‡∞∞‡±Ä",
        'add_entry': "‡∞ï‡±ä‡∞§‡±ç‡∞§ ‡∞é‡∞Ç‡∞ü‡±ç‡∞∞‡±Ä ‡∞ú‡±ã‡∞°‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø",
        'diary_log': "‡∞°‡±à‡∞∞‡±Ä ‡∞≤‡∞æ‡∞ó‡±ç",
        'crop': "‡∞™‡∞Ç‡∞ü",
        'notes': "‡∞ó‡∞Æ‡∞®‡∞ø‡∞ï‡∞≤‡±Å",
        'save_entry': "‡∞é‡∞Ç‡∞ü‡±ç‡∞∞‡±Ä ‡∞∏‡±á‡∞µ‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø",
        'entry_saved': "‡∞é‡∞Ç‡∞ü‡±ç‡∞∞‡±Ä ‡∞∏‡±á‡∞µ‡±ç ‡∞Ö‡∞Ø‡∞ø‡∞Ç‡∞¶‡∞ø!",
        'knowledge_sharing': "‡∞ú‡±ç‡∞û‡∞æ‡∞® ‡∞™‡∞Ç‡∞ö‡±Å‡∞ï‡±ã‡∞≤‡±Å",
        'start_discussion': "‡∞ï‡±ä‡∞§‡±ç‡∞§ ‡∞ö‡∞∞‡±ç‡∞ö ‡∞™‡±ç‡∞∞‡∞æ‡∞∞‡∞Ç‡∞≠‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø",
        'all_discussions': "‡∞Ö‡∞®‡±ç‡∞®‡∞ø ‡∞ö‡∞∞‡±ç‡∞ö‡∞≤‡±Å",
        'post_thread': "‡∞•‡±ç‡∞∞‡≥Ü‡∞°‡±ç ‡∞™‡±ã‡∞∏‡±ç‡∞ü‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø",
        'reply': "‡∞™‡±ç‡∞∞‡∞§‡±ç‡∞Ø‡±Å‡∞§‡±ç‡∞§‡∞∞‡∞Ç",
        'thread_posted': "‡∞•‡±ç‡∞∞‡≥Ü‡∞°‡±ç ‡∞™‡±ã‡∞∏‡±ç‡∞ü‡±ç ‡∞Ö‡∞Ø‡∞ø‡∞Ç‡∞¶‡∞ø!",
        'reply_posted': "‡∞™‡±ç‡∞∞‡∞§‡±ç‡∞Ø‡±Å‡∞§‡±ç‡∞§‡∞∞‡∞Ç ‡∞™‡±ã‡∞∏‡±ç‡∞ü‡±ç ‡∞Ö‡∞Ø‡∞ø‡∞Ç‡∞¶‡∞ø!",
        'soil_health': "‡∞Æ‡∞ü‡±ç‡∞ü‡∞ø ‡∞Ü‡∞∞‡µã‡∞ó‡±ç‡∞Ø ‡∞∏‡±ç‡∞ï‡∞æ‡∞®‡∞ø‡∞Ç‡∞ó‡±ç",
        'add_soil_test': "‡∞ï‡±ä‡∞§‡±ç‡∞§ ‡∞Æ‡∞ü‡±ç‡∞ü‡∞ø ‡∞™‡∞∞‡±Ä‡∞ï‡±ç‡∞∑ ‡∞ú‡±ã‡∞°‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø",
        'soil_test_log': "‡∞Æ‡∞ü‡±ç‡∞ü‡∞ø ‡∞™‡∞∞‡±Ä‡∞ï‡±ç‡∞∑ ‡∞≤‡∞æ‡∞ó‡±ç",
        'save_soil_test': "‡∞Æ‡∞ü‡±ç‡∞ü‡∞ø ‡∞™‡∞∞‡±Ä‡∞ï‡±ç‡∞∑ ‡∞∏‡±á‡∞µ‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø",
        'soil_test_saved': "‡∞Æ‡∞ü‡±ç‡∞ü‡∞ø ‡∞™‡∞∞‡±Ä‡∞ï‡±ç‡∞∑ ‡∞∏‡±á‡∞µ‡±ç ‡∞Ö‡∞Ø‡∞ø‡∞Ç‡∞¶‡∞ø!",
        'heatmaps': "‡∞™‡±ç‡∞∞‡∞§‡±ç‡∞Ø‡∞ï‡±ç‡∞∑ ‡∞µ‡±ç‡∞Ø‡∞µ‡∞∏‡∞æ‡∞Ø ‡∞π‡±Ä‡∞ü‡±ç‚Äå‡∞Æ‡±ç‡∞Ø‡∞æ‡∞™‡±ç‡∞∏‡±ç & ‡∞µ‡±ç‡∞Ø‡∞æ‡∞ß‡∞ø ‡∞µ‡∞ø‡∞ú‡±Å‡∞µ‡∞≤‡±à‡∞ú‡±á‡∞∑‡∞®‡±ç",
        'outbreak_map': "‡∞µ‡±ç‡∞Ø‡∞æ‡∞ß‡∞ø ‡∞Æ‡±ç‡∞Ø‡∞æ‡∞™‡±ç",
        'no_geo_reports': "‡∞ú‡∞ø‡∞Ø‡±ã-‡∞ü‡±ç‡∞Ø‡∞æ‡∞ó‡±ç‡∞°‡±ç ‡∞®‡∞ø‡∞µ‡±á‡∞¶‡∞ø‡∞ï‡∞≤‡±Å ‡∞≤‡±á‡∞µ‡±Å.",
        'report_outbreak': "‡∞ï‡±ä‡∞§‡±ç‡∞§ ‡∞µ‡±ç‡∞Ø‡∞æ‡∞ß‡∞ø‡∞®‡∞ø ‡∞®‡∞ø‡∞µ‡±á‡∞¶‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø",
        'submit_outbreak': "‡∞µ‡±ç‡∞Ø‡∞æ‡∞ß‡∞ø ‡∞®‡∞ø‡∞µ‡±á‡∞¶‡∞ø‡∞ï ‡∞∏‡∞Æ‡∞∞‡±ç‡∞™‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø",
        'outbreak_reported': "‡∞µ‡±ç‡∞Ø‡∞æ‡∞ß‡∞ø ‡∞®‡∞ø‡∞µ‡±á‡∞¶‡∞ø‡∞ï ‡∞∏‡∞Æ‡∞∞‡±ç‡∞™‡∞ø‡∞Ç‡∞ö‡∞¨‡∞°‡∞ø‡∞Ç‡∞¶‡∞ø!",
        'export_info': "‡∞™‡∞∞‡∞ø‡∞∂‡±ã‡∞ß‡∞®, ‡∞∏‡±ç‡∞ü‡∞æ‡∞∞‡±ç‡∞ü‡∞™‡±ç‚Äå‡∞≤‡±Å, ‡∞µ‡∞ø‡∞ß‡∞æ‡∞® ‡∞¨‡±É‡∞Ç‡∞¶‡∞æ‡∞≤ ‡∞ï‡±ã‡∞∏‡∞Ç ‡∞Ö‡∞®‡∞æ‡∞Æ‡∞ï ‡∞°‡±á‡∞ü‡∞æ‡∞®‡±Å ‡∞é‡∞ó‡±Å‡∞Æ‡∞§‡∞ø ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø.",
        'create_export_zip': "‡∞é‡∞ó‡±Å‡∞Æ‡∞§‡∞ø ZIP ‡∞∏‡±É‡∞∑‡±ç‡∞ü‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø",
        'export_created': "‡∞é‡∞ó‡±Å‡∞Æ‡∞§‡∞ø ZIP ‡∞∏‡±É‡∞∑‡±ç‡∞ü‡∞ø‡∞Ç‡∞ö‡∞¨‡∞°‡∞ø‡∞Ç‡∞¶‡∞ø!",
        'download_corpus_zip': "‡∞ï‡∞æ‡∞∞‡±ç‡∞™‡∞∏‡±ç ZIP ‡∞°‡±å‡∞®‡±ç‚Äå‡∞≤‡±ã‡∞°‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø",
        'khet_market': '‡∞ñ‡±á‡∞§‡±ç ‡∞Æ‡∞æ‡∞∞‡±ç‡∞ï‡±Ü‡∞ü‡±ç',
        'market_home': '‡∞π‡±ã‡∞Æ‡±ç',
        'market_login': '‡∞≤‡∞æ‡∞ó‡∞ø‡∞®‡±ç',
        'market_register': '‡∞®‡∞Æ‡±ã‡∞¶‡±Å',
        'market_buyorsell': '‡∞ï‡±ä‡∞®‡±Å‡∞ó‡±ã‡∞≤‡±Å/‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞Ç',
        'market_buy': '‡∞ï‡±ä‡∞®‡±Å‡∞ó‡±ã‡∞≤‡±Å',
        'market_checkout': '‡∞ö‡±Ü‡∞ï‡±å‡∞ü‡±ç',
        'market_payment': '‡∞ö‡±Ü‡∞≤‡±ç‡∞≤‡∞ø‡∞Ç‡∞™‡±Å',
        'market_orders': '‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç‡∞≤‡±Å',
        'market_sell': '‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞Ç',
        'market_selling_item': '‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ø‡∞® ‡∞µ‡∞∏‡±ç‡∞§‡±Å‡∞µ‡±Å',
        'login_username': '‡∞µ‡∞ø‡∞®‡∞ø‡∞Ø‡±ã‡∞ó‡∞¶‡∞æ‡∞∞‡±Å ‡∞™‡±á‡∞∞‡±Å',
        'login_password': '‡∞™‡∞æ‡∞∏‡±ç‡∞µ‡∞∞‡±ç‡∞°‡±ç',
        'login_btn': '‡∞≤‡∞æ‡∞ó‡∞ø‡∞®‡±ç',
        'register_fullname': '‡∞™‡±Ç‡∞∞‡±ç‡∞§‡∞ø ‡∞™‡±á‡∞∞‡±Å',
        'register_email': '‡∞á‡∞Æ‡µÜ‡∞Ø‡∞ø‡∞≤‡±ç',
        'register_phone': '‡∞´‡±ã‡∞®‡±ç',
        'register_username': '‡∞µ‡∞ø‡∞®‡∞ø‡∞Ø‡±ã‡∞ó‡∞¶‡∞æ‡∞∞‡±Å ‡∞™‡±á‡∞∞‡±Å',
        'register_password': '‡∞™‡∞æ‡∞∏‡±ç‡∞µ‡∞∞‡±ç‡∞°‡±ç',
        'register_confirmpw': '‡∞™‡∞æ‡∞∏‡±ç‡∞µ‡∞∞‡±ç‡∞°‡±ç‚Äå‡∞®‡±Å ‡∞®‡∞ø‡∞∞‡±ç‡∞ß‡∞æ‡∞∞‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø',
        'register_btn': '‡∞®‡∞Æ‡±ã‡∞¶‡±Å',
        'buyorsell_buy': '‡∞ï‡±ä‡∞®‡±Å‡∞ó‡±ã‡∞≤‡±Å ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø',
        'buyorsell_sell': '‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞Ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø',
        'payment_card': '‡∞ï‡∞æ‡∞∞‡±ç‡∞°‡±ç ‡∞®‡∞Ç‡∞¨‡∞∞‡±ç',
        'payment_expiry': '‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞§‡±á‡∞¶‡±Ä',
        'payment_cvv': '‡∞∏‡∞ø‡∞µ‡∞ø‡∞µ‡∞ø',
        'payment_btn': '‡∞ö‡±Ü‡∞≤‡±ç‡∞≤‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø',
        'sell_crop': '‡∞™‡∞Ç‡∞ü ‡∞™‡±á‡∞∞‡±Å',
        'sell_qty': '‡∞™‡∞∞‡∞ø‡∞Æ‡∞æ‡∞£‡∞Ç (‡∞ï‡∞ø‡∞≤‡±ã‡∞≤‡±Å)',
        'sell_price': '‡∞ß‡∞∞ (‡∞™‡±ç‡∞∞‡∞§‡∞ø ‡∞ï‡∞ø‡∞≤‡±ã, MSP ‡∞ï‡∞®‡±ç‡∞®‡∞æ ‡∞é‡∞ï‡±ç‡∞ï‡±Å‡∞µ)',
        'sell_img': '‡∞™‡∞Ç‡∞ü ‡∞ö‡∞ø‡∞§‡±ç‡∞∞‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞Ö‡∞™‡±ç‚Äå‡∞≤‡±ã‡∞°‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø',
        'sell_btn': '‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞®‡∞ø‡∞ï‡∞ø ‡∞ú‡∞æ‡∞¨‡∞ø‡∞§‡∞æ ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø',
        'output': '‡∞µ‡±Ü‡∞≥‡±ç‡∞≥‡∞ø‡∞® ‡∞µ‡∞ø‡∞∑‡∞Ø‡∞Ç',
        'context': '‡∞µ‡∞ø‡∞∑‡∞Ø‡∞æ‡∞®‡∞ø‡∞ï‡∞ø ‡∞∏‡∞Æ‡∞æ‡∞ö‡∞æ‡∞∞‡∞Ç ‡∞á‡∞µ‡±ç‡∞µ‡∞Ç‡∞°‡∞ø',
        'enter_context': '‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞µ‡∞ø‡∞∑‡∞Ø‡∞æ‡∞®‡∞ø‡∞ï‡∞ø ‡∞∏‡∞Æ‡∞æ‡∞ö‡∞æ‡∞∞‡∞Ç ‡∞á‡∞µ‡±ç‡∞µ‡∞Ç‡∞°‡∞ø.',
        'agribot_title': "ü§ñ AgriBot - Your Futuristic Agricultural Assistant",
        'agribot_greeting': "Hello! I'm AgriBot. How can I assist you with your farm today?",
        'agribot_input_placeholder': "Type your message here...",
        'agribot_attach_image': "Attach image (optional)",
        'send': "Send",
        'show_history': "Show Conversation History",
        'you': "You",
        'agribot': "AgriBot",
        'analytics_dashboard': "üìä Analytics Dashboard",
        'analytics_total_questions': "Total AgriBot Questions Asked",
        'analytics_common_crops': "Most Common Crops Discussed",
        'analytics_disease_trends': "Disease Diagnosis Trends",
        'analytics_engagement': "User Engagement Over Time",
        'analytics_pie_types': "Pie Chart of Question Types",
        'analytics_recent_log': "Recent Activity Log",
        'analytics_upload_csv': "Upload a CSV file for visualization",
        'analytics_no_data': "No chat data to display.",
        'analytics_no_conversations': "No conversation data found.",
        'analytics_no_keywords': "No crop keywords found in chats.",
        'analytics_no_disease': "No disease keywords found in chats.",
        'analytics_no_types': "No question type data found.",
        'analytics_info_upload': "If you want to visualize other CSV/statistics, upload them below:",
    },
    'hi': {
        'app_title': "üåæ KrishiSakhi: ‡§è‡§Ü‡§à ‡§∏‡§Ç‡§ö‡§æ‡§≤‡§ø‡§§ ‡§ï‡•É‡§∑‡§ø ‡§∏‡§π‡§æ‡§Ø‡§ï üåæ",
        'home': "‡§π‡•ã‡§Æ",
        'recommendations': "‡§∏‡§ø‡§´‡§æ‡§∞‡§ø‡§∂‡•á‡§Ç ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡•á‡§Ç",
        'diagnosis': "‡§è‡§Ü‡§à ‡§∞‡•ã‡§ó ‡§®‡§ø‡§¶‡§æ‡§®",
        'validation': "‡§ï‡§ø‡§∏‡§æ‡§® ‡§∏‡§§‡•ç‡§Ø‡§æ‡§™‡§®",
        'language': "‡§≠‡§æ‡§∑‡§æ",
        'select_language': "‡§≠‡§æ‡§∑‡§æ ‡§ö‡•Å‡§®‡•á‡§Ç",
        'weather': "‡§Æ‡•å‡§∏‡§Æ ‡§™‡•Ç‡§∞‡•ç‡§µ‡§æ‡§®‡•Å‡§Æ‡§æ‡§®",
        'input_options': "‡§á‡§®‡§™‡•Å‡§ü ‡§µ‡§ø‡§ï‡§≤‡•ç‡§™",
        'image_input': "‡§õ‡§µ‡§ø ‡§Ö‡§™‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç",
        'voice_input': "‡§µ‡•â‡§Ø‡§∏ ‡§á‡§®‡§™‡•Å‡§ü",
        'text_input': "‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§á‡§®‡§™‡•Å‡§ü",
        'submit': "‡§∏‡§¨‡§Æ‡§ø‡§ü ‡§ï‡§∞‡•á‡§Ç",
        'severity': "‡§∞‡•ã‡§ó ‡§ï‡•Ä ‡§ó‡§Ç‡§≠‡•Ä‡§∞‡§§‡§æ ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§Æ‡§æ‡§®",
        'correction': "‡§ï‡§ø‡§∏‡§æ‡§® ‡§∏‡•Å‡§ß‡§æ‡§∞ ‡§µ‡§∞‡•ç‡§ï‡§´‡§º‡•ç‡§≤‡•ã",
        'enter_farm_data': "‡§´‡§æ‡§∞‡•ç‡§Æ ‡§°‡•á‡§ü‡§æ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç",
        'farm_id': "‡§´‡§æ‡§∞‡•ç‡§Æ ‡§Ü‡§à‡§°‡•Ä",
        'soil_ph': "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡§æ ‡§™‡•Ä‡§è‡§ö ‡§Æ‡§æ‡§®",
        'soil_moisture': "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡•Ä ‡§®‡§Æ‡•Ä (%)",
        'temperature': "‡§§‡§æ‡§™‡§Æ‡§æ‡§® (¬∞C)",
        'rainfall': "‡§µ‡§∞‡•ç‡§∑‡§æ (‡§Æ‡§ø‡§Æ‡•Ä)",
        'crop_type': "‡§´‡§∏‡§≤ ‡§ï‡§æ ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞",
        'fertilizer_usage': "‡§â‡§∞‡•ç‡§µ‡§∞‡§ï ‡§â‡§™‡§Ø‡•ã‡§ó (‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ)",
        'pesticide_usage': "‡§ï‡•Ä‡§ü‡§®‡§æ‡§∂‡§ï ‡§â‡§™‡§Ø‡•ã‡§ó (‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ)",
        'crop_yield': "‡§´‡§∏‡§≤ ‡§â‡§§‡•ç‡§™‡§æ‡§¶‡§® (‡§ü‡§®)",
        'sustainability_score': "‡§∏‡§∏‡•ç‡§ü‡•á‡§®‡•á‡§¨‡§ø‡§≤‡§ø‡§ü‡•Ä ‡§∏‡•ç‡§ï‡•ã‡§∞",
        'select_crop': "‡§¨‡§æ‡§ú‡§æ‡§∞/‡§Æ‡•å‡§∏‡§Æ/‡§∏‡§∏‡•ç‡§ü‡•á‡§®‡•á‡§¨‡§ø‡§≤‡§ø‡§ü‡•Ä ‡§∏‡§≤‡§æ‡§π ‡§ï‡•á ‡§≤‡§ø‡§è ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§´‡§∏‡§≤ ‡§ö‡•Å‡§®‡•á‡§Ç",
        'get_recommendations': "‡§∏‡§ø‡§´‡§æ‡§∞‡§ø‡§∂‡•á‡§Ç ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡•á‡§Ç",
        'soil_recommendations': "üßæ ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§∏‡§ø‡§´‡§æ‡§∞‡§ø‡§∂‡•á‡§Ç",
        'market_trends': "üìà ‡§¨‡§æ‡§ú‡§æ‡§∞ ‡§™‡•ç‡§∞‡§µ‡•É‡§§‡•ç‡§§‡§ø‡§Ø‡§æ‡§Å",
        'weather_forecast': "üå§Ô∏è ‡§Æ‡•å‡§∏‡§Æ ‡§™‡•Ç‡§∞‡•ç‡§µ‡§æ‡§®‡•Å‡§Æ‡§æ‡§®",
        'sustainable_practices': "üå± ‡§∏‡§§‡§§ ‡§™‡•ç‡§∞‡§•‡§æ‡§è‡§Å",
        'ai_diagnosis': "‡§è‡§Ü‡§à ‡§®‡§ø‡§¶‡§æ‡§® ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ",
        'severity_result': "‡§Ö‡§®‡•Å‡§Æ‡§æ‡§®‡§ø‡§§ ‡§ó‡§Ç‡§≠‡•Ä‡§∞‡§§‡§æ",
        'validation_prompt': "‡§ï‡•ç‡§Ø‡§æ ‡§®‡§ø‡§¶‡§æ‡§® ‡§∏‡§π‡•Ä ‡§π‡•à?",
        'correction_prompt': "‡§ï‡•É‡§™‡§Ø‡§æ ‡§∏‡§π‡•Ä ‡§®‡§ø‡§¶‡§æ‡§® ‡§™‡•ç‡§∞‡§¶‡§æ‡§® ‡§ï‡§∞‡•á‡§Ç:",
        'thank_you': "‡§Ü‡§™‡§ï‡•Ä ‡§™‡•ç‡§∞‡§§‡§ø‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶!",
        'back_home': "‡§π‡•ã‡§Æ ‡§™‡§∞ ‡§µ‡§æ‡§™‡§∏ ‡§ú‡§æ‡§è‡§Å",
        'growth_diary': "‡§µ‡•É‡§¶‡•ç‡§ß‡§ø ‡§°‡§æ‡§Ø‡§∞‡•Ä",
        'add_entry': "‡§®‡§à ‡§™‡•ç‡§∞‡§µ‡§ø‡§∑‡•ç‡§ü‡§ø ‡§ú‡•ã‡§°‡§º‡•á‡§Ç",
        'diary_log': "‡§°‡§æ‡§Ø‡§∞‡•Ä ‡§≤‡•â‡§ó",
        'crop': "‡§´‡§∏‡§≤",
        'notes': "‡§ü‡§ø‡§™‡•ç‡§™‡§£‡§ø‡§Ø‡§æ‡§Å",
        'save_entry': "‡§™‡•ç‡§∞‡§µ‡§ø‡§∑‡•ç‡§ü‡§ø ‡§∏‡§π‡•á‡§ú‡•á‡§Ç",
        'entry_saved': "‡§™‡•ç‡§∞‡§µ‡§ø‡§∑‡•ç‡§ü‡§ø ‡§∏‡§π‡•á‡§ú‡•Ä ‡§ó‡§à!",
        'knowledge_sharing': "‡§ú‡•ç‡§û‡§æ‡§® ‡§∏‡§æ‡§ù‡§æ ‡§ï‡§∞‡§®‡§æ",
        'start_discussion': "‡§®‡§à ‡§ö‡§∞‡•ç‡§ö‡§æ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç",
        'all_discussions': "‡§∏‡§≠‡•Ä ‡§ö‡§∞‡•ç‡§ö‡§æ‡§è‡§Å",
        'post_thread': "‡§•‡•ç‡§∞‡•á‡§° ‡§™‡•ã‡§∏‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç",
        'reply': "‡§â‡§§‡•ç‡§§‡§∞",
        'thread_posted': "‡§•‡•ç‡§∞‡•á‡§° ‡§™‡•ã‡§∏‡•ç‡§ü ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ!",
        'reply_posted': "‡§â‡§§‡•ç‡§§‡§∞ ‡§™‡•ã‡§∏‡•ç‡§ü ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ!",
        'soil_health': "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§∏‡•ç‡§ï‡•à‡§®‡§ø‡§Ç‡§ó",
        'add_soil_test': "‡§®‡§à ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§™‡§∞‡•Ä‡§ï‡•ç‡§∑‡§£ ‡§ú‡•ã‡§°‡§º‡•á‡§Ç",
        'soil_test_log': "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§™‡§∞‡•Ä‡§ï‡•ç‡§∑‡§£ ‡§≤‡•â‡§ó",
        'save_soil_test': "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§™‡§∞‡•Ä‡§ï‡•ç‡§∑‡§£ ‡§∏‡§π‡•á‡§ú‡•á‡§Ç",
        'soil_test_saved': "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§™‡§∞‡•Ä‡§ï‡•ç‡§∑‡§£ ‡§∏‡§π‡•á‡§ú‡§æ ‡§ó‡§Ø‡§æ!",
        'heatmaps': "‡§≤‡§æ‡§á‡§µ ‡§ï‡•É‡§∑‡§ø ‡§π‡•Ä‡§ü‡§Æ‡•à‡§™‡•ç‡§∏ ‡§î‡§∞ ‡§™‡•ç‡§∞‡§ï‡•ã‡§™ ‡§µ‡§ø‡§ú‡§º‡•Å‡§Ö‡§≤‡§æ‡§á‡§ú‡§º‡•á‡§∂‡§®",
        'outbreak_map': "‡§™‡•ç‡§∞‡§ï‡•ã‡§™ ‡§Æ‡§æ‡§®‡§ö‡§ø‡§§‡•ç‡§∞",
        'no_geo_reports': "‡§ï‡•ã‡§à ‡§ú‡§ø‡§Ø‡•ã-‡§ü‡•à‡§ó‡•ç‡§° ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡•§",
        'report_outbreak': "‡§®‡§à ‡§™‡•ç‡§∞‡§ï‡•ã‡§™ ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç",
        'submit_outbreak': "‡§™‡•ç‡§∞‡§ï‡•ã‡§™ ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü ‡§∏‡§¨‡§Æ‡§ø‡§ü ‡§ï‡§∞‡•á‡§Ç",
        'outbreak_reported': "‡§™‡•ç‡§∞‡§ï‡•ã‡§™ ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü ‡§ï‡•Ä ‡§ó‡§à!",
        'export_info': "‡§Ö‡§®‡•Å‡§∏‡§Ç‡§ß‡§æ‡§®, ‡§∏‡•ç‡§ü‡§æ‡§∞‡•ç‡§ü‡§Ö‡§™‡•ç‡§∏ ‡§î‡§∞ ‡§®‡•Ä‡§§‡§ø ‡§ü‡•Ä‡§Æ‡•ã‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∏‡§≠‡•Ä ‡§Ö‡§®‡§æ‡§Æ ‡§°‡•á‡§ü‡§æ ‡§®‡§ø‡§∞‡•ç‡§Ø‡§æ‡§§ ‡§ï‡§∞‡•á‡§Ç‡•§",
        'create_export_zip': "‡§®‡§ø‡§∞‡•ç‡§Ø‡§æ‡§§ ZIP ‡§¨‡§®‡§æ‡§è‡§Ç",
        'export_created': "‡§®‡§ø‡§∞‡•ç‡§Ø‡§æ‡§§ ZIP ‡§¨‡§®‡§æ‡§Ø‡§æ ‡§ó‡§Ø‡§æ!",
        'download_corpus_zip': "‡§ï‡•â‡§∞‡•ç‡§™‡§∏ ZIP ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç",
        'khet_market': '‡§ñ‡•á‡§§‡•Ä ‡§¨‡§æ‡§ú‡§æ‡§∞',
        'market_home': '‡§π‡•ã‡§Æ',
        'market_login': '‡§≤‡•â‡§ó‡§ø‡§®',
        'market_register': '‡§∞‡§ú‡§ø‡§∏‡•ç‡§ü‡§∞',
        'market_buyorsell': '‡§ñ‡§∞‡•Ä‡§¶‡•á‡§Ç/‡§¨‡•á‡§ö‡•á‡§Ç',
        'market_buy': '‡§ñ‡§∞‡•Ä‡§¶‡•á‡§Ç',
        'market_checkout': '‡§ö‡•á‡§ï‡§Ü‡§â‡§ü',
        'market_payment': '‡§≠‡•Å‡§ó‡§§‡§æ‡§®',
        'market_orders': '‡§ë‡§∞‡•ç‡§°‡§∞',
        'market_sell': '‡§¨‡•á‡§ö‡•á‡§Ç',
        'market_selling_item': '‡§¨‡•á‡§ö‡•Ä ‡§ó‡§à ‡§µ‡§∏‡•ç‡§§‡•Å',
        'login_username': '‡§â‡§™‡§Ø‡•ã‡§ó‡§ï‡§∞‡•ç‡§§‡§æ ‡§®‡§æ‡§Æ',
        'login_password': '‡§™‡§æ‡§∏‡§µ‡§∞‡•ç‡§°',
        'login_btn': '‡§≤‡•â‡§ó‡§ø‡§®',
        'register_fullname': '‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ',
        'register_email': '‡§à‡§Æ‡•á‡§≤',
        'register_phone': '‡§´‡§º‡•ã‡§®',
        'register_username': '‡§â‡§™‡§Ø‡•ã‡§ó‡§ï‡§∞‡•ç‡§§‡§æ ‡§®‡§æ‡§Æ',
        'register_password': '‡§™‡§æ‡§∏‡§µ‡§∞‡•ç‡§°',
        'register_confirmpw': '‡§™‡§æ‡§∏‡§µ‡§∞‡•ç‡§° ‡§ï‡•Ä ‡§™‡•Å‡§∑‡•ç‡§ü‡§ø ‡§ï‡§∞‡•á‡§Ç',
        'register_btn': '‡§∞‡§ú‡§ø‡§∏‡•ç‡§ü‡§∞',
        'buyorsell_buy': '‡§ñ‡§∞‡•Ä‡§¶‡•á‡§Ç ‡§™‡§∞ ‡§ú‡§æ‡§è‡§Ç',
        'buyorsell_sell': '‡§¨‡•á‡§ö‡•á‡§Ç ‡§™‡§∞ ‡§ú‡§æ‡§è‡§Ç',
        'payment_card': '‡§ï‡§æ‡§∞‡•ç‡§° ‡§®‡§Ç‡§¨‡§∞',
        'payment_expiry': '‡§∏‡§Æ‡§æ‡§™‡•ç‡§§‡§ø ‡§§‡§ø‡§•‡§ø',
        'payment_cvv': '‡§∏‡•Ä‡§µ‡•Ä‡§µ‡•Ä',
        'payment_btn': '‡§≠‡•Å‡§ó‡§§‡§æ‡§® ‡§ï‡§∞‡•á‡§Ç',
        'sell_crop': '‡§´‡§∏‡§≤ ‡§ï‡§æ ‡§®‡§æ‡§Æ',
        'sell_qty': '‡§Æ‡§æ‡§§‡•ç‡§∞‡§æ (‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ)',
        'sell_price': '‡§Æ‡•Ç‡§≤‡•ç‡§Ø (‡§™‡•ç‡§∞‡§§‡§ø ‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ, MSP ‡§∏‡•á ‡§Ö‡§ß‡§ø‡§ï)',
        'sell_img': '‡§´‡§∏‡§≤ ‡§õ‡§µ‡§ø ‡§Ö‡§™‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç',
        'sell_btn': '‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∏‡•Ç‡§ö‡•Ä‡§¨‡§¶‡•ç‡§ß ‡§ï‡§∞‡•á‡§Ç',
        'output': '‡§Ü‡§â‡§ü‡§™‡•Å‡§ü',
        'context': 'Q&A ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∏‡§Ç‡§¶‡§∞‡•ç‡§≠ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç',
        'enter_context': '‡§ï‡•É‡§™‡§Ø‡§æ Q&A ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∏‡§Ç‡§¶‡§∞‡•ç‡§≠ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç.',
        'agribot_title': "ü§ñ AgriBot - Your Futuristic Agricultural Assistant",
        'agribot_greeting': "Hello! I'm AgriBot. How can I assist you with your farm today?",
        'agribot_input_placeholder': "Type your message here...",
        'agribot_attach_image': "Attach image (optional)",
        'send': "Send",
        'show_history': "Show Conversation History",
        'you': "You",
        'agribot': "AgriBot",
        'analytics_dashboard': "üìä Analytics Dashboard",
        'analytics_total_questions': "Total AgriBot Questions Asked",
        'analytics_common_crops': "Most Common Crops Discussed",
        'analytics_disease_trends': "Disease Diagnosis Trends",
        'analytics_engagement': "User Engagement Over Time",
        'analytics_pie_types': "Pie Chart of Question Types",
        'analytics_recent_log': "Recent Activity Log",
        'analytics_upload_csv': "Upload a CSV file for visualization",
        'analytics_no_data': "No chat data to display.",
        'analytics_no_conversations': "No conversation data found.",
        'analytics_no_keywords': "No crop keywords found in chats.",
        'analytics_no_disease': "No disease keywords found in chats.",
        'analytics_no_types': "No question type data found.",
        'analytics_info_upload': "If you want to visualize other CSV/statistics, upload them below:",
    },
    'ta': {
        'app_title': "üåæ ‡Æï‡Æø‡Æ∞‡ØÅ‡Æ∑‡Æø ‡Æö‡Æï‡Æø: ‡Æè‡Æê ‡Æá‡ÆØ‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç ‡Æµ‡Æø‡Æµ‡Æö‡Ææ‡ÆØ ‡Æâ‡Æ§‡Æµ‡Æø‡ÆØ‡Ææ‡Æ≥‡Æ∞‡Øç üåæ",
        'home': "‡ÆÆ‡ØÅ‡Æï‡Æ™‡Øç‡Æ™‡ØÅ",
        'recommendations': "‡Æ™‡Æ∞‡Æø‡Æ®‡Øç‡Æ§‡ØÅ‡Æ∞‡Øà‡Æï‡Æ≥‡Øç ‡Æ™‡ØÜ‡Æ±‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç",
        'diagnosis': "‡Æè‡Æê ‡Æ®‡Øã‡ÆØ‡Øç ‡Æï‡Æ£‡Øç‡Æü‡Æ±‡Æø‡Æ§‡Æ≤‡Øç",
        'validation': "‡Æµ‡Æø‡Æµ‡Æö‡Ææ‡ÆØ‡Æø ‡Æö‡Æ∞‡Æø‡Æ™‡Ææ‡Æ∞‡Øç‡Æ™‡Øç‡Æ™‡ØÅ",
        'language': "‡ÆÆ‡Øä‡Æ¥‡Æø",
        'select_language': "‡ÆÆ‡Øä‡Æ¥‡Æø‡ÆØ‡Øà‡Æ§‡Øç ‡Æ§‡Øá‡Æ∞‡Øç‡Æ®‡Øç‡Æ§‡ØÜ‡Æü‡ØÅ‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç",
        'weather': "‡Æµ‡Ææ‡Æ©‡Æø‡Æ≤‡Øà ‡ÆÆ‡ØÅ‡Æ©‡Øç‡Æ©‡Æ±‡Æø‡Æµ‡ØÅ",
        'input_options': "‡Æâ‡Æ≥‡Øç‡Æ≥‡ØÄ‡Æü‡Øç‡Æü‡ØÅ ‡Æµ‡Æø‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡Æô‡Øç‡Æï‡Æ≥‡Øç",
        'image_input': "‡Æ™‡Æü‡Æ§‡Øç‡Æ§‡Øà ‡Æ™‡Æ§‡Æø‡Æµ‡Øá‡Æ±‡Øç‡Æ±‡Æµ‡ØÅ‡ÆÆ‡Øç",
        'voice_input': "‡Æï‡ØÅ‡Æ∞‡Æ≤‡Øç ‡Æâ‡Æ≥‡Øç‡Æ≥‡ØÄ‡Æü‡ØÅ",
        'text_input': "‡Æâ‡Æ∞‡Øà ‡Æâ‡Æ≥‡Øç‡Æ≥‡ØÄ‡Æü‡ØÅ",
        'submit': "‡Æö‡ÆÆ‡Æ∞‡Øç‡Æ™‡Øç‡Æ™‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç",
        'severity': "‡Æ®‡Øã‡ÆØ‡Øç ‡Æ§‡ØÄ‡Æµ‡Æø‡Æ∞‡ÆÆ‡Øç ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÄ‡Æü‡ØÅ",
        'correction': "‡Æµ‡Æø‡Æµ‡Æö‡Ææ‡ÆØ‡Æø ‡Æ§‡Æø‡Æ∞‡ØÅ‡Æ§‡Øç‡Æ§‡ÆÆ‡Øç",
        'enter_farm_data': "‡Æ™‡Æ£‡Øç‡Æ£‡Øà ‡Æ§‡Æ∞‡Æµ‡Øà ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æø‡Æü‡Æµ‡ØÅ‡ÆÆ‡Øç",
        'farm_id': "‡Æ™‡Æ£‡Øç‡Æ£‡Øà ‡Æê‡Æü‡Æø",
        'soil_ph': "‡ÆÆ‡Æ£‡Øç ‡Æ™‡Æø‡Æπ‡ØÜ‡Æö‡Øç ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ",
        'soil_moisture': "‡ÆÆ‡Æ£‡Øç ‡Æà‡Æ∞‡Æ™‡Øç‡Æ™‡Æ§‡ÆÆ‡Øç (%)",
        'temperature': "‡Æµ‡ØÜ‡Æ™‡Øç‡Æ™‡Æ®‡Æø‡Æ≤‡Øà (¬∞C)",
        'rainfall': "‡ÆÆ‡Æ¥‡Øà (‡ÆÆ‡Æø‡ÆÆ‡ØÄ)",
        'crop_type': "‡Æ™‡ÆØ‡Æø‡Æ∞‡Øç ‡Æµ‡Æï‡Øà",
        'fertilizer_usage': "‡Æâ‡Æ∞ ‡Æ™‡ÆØ‡Æ©‡Øç‡Æ™‡Ææ‡Æü‡ØÅ (‡Æï‡Æø‡Æ≤‡Øã)",
        'pesticide_usage': "‡Æ™‡ØÇ‡Æö‡Øç‡Æö‡Æø‡Æï‡Øç‡Æï‡Øä‡Æ≤‡Øç‡Æ≤‡Æø ‡Æ™‡ÆØ‡Æ©‡Øç‡Æ™‡Ææ‡Æü‡ØÅ (‡Æï‡Æø‡Æ≤‡Øã)",
        'crop_yield': "‡Æ™‡ÆØ‡Æø‡Æ∞‡Øç ‡Æµ‡Æø‡Æ≥‡Øà‡Æö‡Øç‡Æö‡Æ≤‡Øç (‡Æü‡Æ©‡Øç)",
        'sustainability_score': "‡Æ§‡Æø‡Æü‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡Æ≤‡Øç ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÜ‡Æ£‡Øç",
        'select_crop': "‡Æö‡Æ®‡Øç‡Æ§‡Øà/‡Æµ‡Ææ‡Æ©‡Æø‡Æ≤‡Øà/‡Æ§‡Æø‡Æü‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡Æ≤‡Øç ‡ÆÜ‡Æ≤‡Øã‡Æö‡Æ©‡Øà‡Æï‡Øç‡Æï‡ØÅ ‡Æ™‡ÆØ‡Æø‡Æ∞‡Øà‡Æ§‡Øç ‡Æ§‡Øá‡Æ∞‡Øç‡Æ®‡Øç‡Æ§‡ØÜ‡Æü‡ØÅ‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç",
        'get_recommendations': "‡Æ™‡Æ∞‡Æø‡Æ®‡Øç‡Æ§‡ØÅ‡Æ∞‡Øà‡Æï‡Æ≥‡Øç ‡Æ™‡ØÜ‡Æ±‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç",
        'soil_recommendations': "üßæ ‡ÆÆ‡Æ£‡Øç ‡Æ™‡Æ∞‡Æø‡Æ®‡Øç‡Æ§‡ØÅ‡Æ∞‡Øà‡Æï‡Æ≥‡Øç",
        'market_trends': "üìà ‡Æö‡Æ®‡Øç‡Æ§‡Øà ‡Æ™‡Øã‡Æï‡Øç‡Æï‡ØÅ‡Æï‡Æ≥‡Øç",
        'weather_forecast': "üå§Ô∏è ‡Æµ‡Ææ‡Æ©‡Æø‡Æ≤‡Øà ‡ÆÆ‡ØÅ‡Æ©‡Øç‡Æ©‡Æ±‡Æø‡Æµ‡ØÅ",
        'sustainable_practices': "üå± ‡Æ§‡Æø‡Æü‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡Æ≤‡Øç ‡Æ®‡Æü‡Øà‡ÆÆ‡ØÅ‡Æ±‡Øà‡Æï‡Æ≥‡Øç",
        'ai_diagnosis': "‡Æè‡Æê ‡Æï‡Æ£‡Øç‡Æü‡Æ±‡Æø‡Æ§‡Æ≤‡Øç ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æµ‡ØÅ",
        'severity_result': "‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡Æø‡Æü‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü ‡Æ§‡ØÄ‡Æµ‡Æø‡Æ∞‡ÆÆ‡Øç",
        'validation_prompt': "‡ÆÆ‡Øá‡Æ≤‡ØÅ‡Æ≥‡Øç‡Æ≥ ‡Æ§‡Æï‡Æµ‡Æ≤‡Øç ‡Æö‡Æ∞‡Æø‡ÆØ‡Ææ?",
        'correction_prompt': "‡Æö‡Æ∞‡Æø‡ÆØ‡Ææ‡Æ© ‡Æï‡Æ£‡Øç‡Æü‡Æ±‡Æø‡Æ§‡Æ≤‡Øà ‡Æµ‡Æ¥‡Æô‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç:",
        'thank_you': "‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æï‡Æ∞‡ØÅ‡Æ§‡Øç‡Æ§‡ØÅ‡Æï‡Øç‡Æï‡ØÅ ‡Æ®‡Æ©‡Øç‡Æ±‡Æø!",
        'back_home': "‡ÆÆ‡ØÅ‡Æï‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Øç‡Æï‡ØÅ ‡Æ§‡Æø‡Æ∞‡ØÅ‡ÆÆ‡Øç‡Æ™‡Æµ‡ØÅ‡ÆÆ‡Øç",
        'growth_diary': '‡Æµ‡Æ≥‡Æ∞‡Øç‡Æö‡Øç‡Æö‡Æø ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡ØÅ',
        'add_entry': '‡Æ™‡ØÅ‡Æ§‡Æø‡ÆØ ‡Æ™‡Æ§‡Æø‡Æµ‡Øà‡Æö‡Øç ‡Æö‡Øá‡Æ∞‡Øç‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç',
        'diary_log': '‡Æ®‡Ææ‡Æü‡Øç‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡ØÅ ‡Æ™‡Æ§‡Æø‡Æµ‡ØÅ',
        'crop': '‡Æ™‡ÆØ‡Æø‡Æ∞‡Øç',
        'notes': '‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Øç',
        'save_entry': '‡Æ™‡Æ§‡Æø‡Æµ‡Øà ‡Æö‡Øá‡ÆÆ‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç',
        'entry_saved': '‡Æ™‡Æ§‡Æø‡Æµ‡ØÅ ‡Æö‡Øá‡ÆÆ‡Æø‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ!',
        'knowledge_sharing': '‡ÆÖ‡Æ±‡Æø‡Æµ‡ØÅ ‡Æ™‡Æï‡Æø‡Æ∞‡Øç‡Æµ‡ØÅ',
        'start_discussion': '‡Æ™‡ØÅ‡Æ§‡Æø‡ÆØ ‡Æµ‡Æø‡Æµ‡Ææ‡Æ§‡Æ§‡Øç‡Æ§‡Øà‡Æ§‡Øç ‡Æ§‡Øä‡Æü‡Æô‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç',
        'all_discussions': '‡ÆÖ‡Æ©‡Øà‡Æ§‡Øç‡Æ§‡ØÅ ‡Æµ‡Æø‡Æµ‡Ææ‡Æ§‡Æô‡Øç‡Æï‡Æ≥‡Øç',
        'post_thread': '‡Æ§‡Æ≤‡Øà‡Æ™‡Øç‡Æ™‡Øà ‡Æá‡Æü‡ØÅ‡Æï‡Øà‡ÆØ‡Æø‡Æü‡Æµ‡ØÅ‡ÆÆ‡Øç',
        'reply': '‡Æ™‡Æ§‡Æø‡Æ≤‡Øç',
        'thread_posted': '‡Æ§‡Æ≤‡Øà‡Æ™‡Øç‡Æ™‡ØÅ ‡Æá‡Æü‡ØÅ‡Æï‡Øà‡ÆØ‡Æø‡Æü‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ!',
        'reply_posted': '‡Æ™‡Æ§‡Æø‡Æ≤‡Øç ‡Æá‡Æü‡ØÅ‡Æï‡Øà‡ÆØ‡Æø‡Æü‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ!',
        'soil_health': '‡ÆÆ‡Æ£‡Øç ‡ÆÜ‡Æ∞‡Øã‡Æï‡Øç‡Æï‡Æø‡ÆØ‡ÆÆ‡Øç ‡Æ∏‡Øç‡Æï‡Øá‡Æ©‡Æø‡Æô‡Øç',
        'add_soil_test': '‡Æ™‡ØÅ‡Æ§‡Æø‡ÆØ ‡ÆÆ‡Æ£‡Øç ‡Æ™‡Æ∞‡Æø‡Æö‡Øã‡Æ§‡Æ©‡Øà ‡Æö‡Øá‡Æ∞‡Øç‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç',
        'soil_test_log': '‡ÆÆ‡Æ£‡Øç ‡Æ™‡Æ∞‡Æø‡Æö‡Øã‡Æ§‡Æ©‡Øà ‡Æ™‡Æ§‡Æø‡Æµ‡ØÅ',
        'save_soil_test': '‡ÆÆ‡Æ£‡Øç ‡Æ™‡Æ∞‡Æø‡Æö‡Øã‡Æ§‡Æ©‡Øà ‡Æö‡Øá‡ÆÆ‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç',
        'soil_test_saved': '‡ÆÆ‡Æ£‡Øç ‡Æ™‡Æ∞‡Æø‡Æö‡Øã‡Æ§‡Æ©‡Øà ‡Æö‡Øá‡ÆÆ‡Æø‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ!',
        'heatmaps': '‡Æ®‡Øá‡Æ∞‡Æü‡Æø ‡Æµ‡Æø‡Æµ‡Æö‡Ææ‡ÆØ ‡Æπ‡ØÄ‡Æü‡Øç‡ÆÆ‡Øá‡Æ™‡Øç‡Æï‡Æ≥‡Øç & ‡Æ®‡Øã‡ÆØ‡Øç ‡Æ™‡Æ∞‡Æµ‡Æ≤‡Øç ‡Æï‡Ææ‡Æü‡Øç‡Æö‡Æø',
        'outbreak_map': '‡Æ®‡Øã‡ÆØ‡Øç ‡Æ™‡Æ∞‡Æµ‡Æ≤‡Øç ‡Æµ‡Æ∞‡Øà‡Æ™‡Æü‡ÆÆ‡Øç',
        'no_geo_reports': '‡Æú‡Æø‡ÆØ‡Øã-‡Æü‡Øá‡Æï‡Øç ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà‡Æï‡Æ≥‡Øç ‡Æá‡Æ≤‡Øç‡Æ≤‡Øà.',
        'report_outbreak': '‡Æ™‡ØÅ‡Æ§‡Æø‡ÆØ ‡Æ®‡Øã‡ÆØ‡Øç ‡Æ™‡Æ∞‡Æµ‡Æ≤‡Øà ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà‡ÆØ‡Æø‡Æü‡Æµ‡ØÅ‡ÆÆ‡Øç',
        'submit_outbreak': '‡Æ®‡Øã‡ÆØ‡Øç ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà‡ÆØ‡Øà ‡Æö‡ÆÆ‡Æ∞‡Øç‡Æ™‡Øç‡Æ™‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç',
        'outbreak_reported': '‡Æ®‡Øã‡ÆØ‡Øç ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà ‡Æö‡ÆÆ‡Æ∞‡Øç‡Æ™‡Øç‡Æ™‡Æø‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ!',
        'khet_market': '‡Æï‡Øá‡Æ§‡Øç ‡ÆÆ‡Ææ‡Æ∞‡Øç‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç',
        'market_home': '‡ÆÆ‡ØÅ‡Æï‡Æ™‡Øç‡Æ™‡ØÅ',
        'market_login': '‡Æâ‡Æ≥‡Øç‡Æ®‡ØÅ‡Æ¥‡Øà',
        'market_register': '‡Æ™‡Æ§‡Æø‡Æµ‡ØÅ',
        'market_buyorsell': '‡Æµ‡Ææ‡Æô‡Øç‡Æï/‡Æµ‡Æø‡Æ±‡Øç‡Æï',
        'market_buy': '‡Æµ‡Ææ‡Æô‡Øç‡Æï',
        'market_checkout': '‡Æö‡ØÜ‡Æï‡Øç ‡ÆÖ‡Æµ‡ØÅ‡Æü‡Øç',
        'market_payment': '‡Æï‡Æü‡Øç‡Æü‡Æ£‡ÆÆ‡Øç',
        'market_orders': '‡ÆÜ‡Æ£‡Øà‡Æï‡Æ≥‡Øç',
        'market_sell': '‡Æµ‡Æø‡Æ±‡Øç‡Æï',
        'market_selling_item': '‡Æµ‡Æø‡Æ±‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç ‡Æ™‡Øä‡Æ∞‡ØÅ‡Æ≥‡Øç',
        'login_username': '‡Æ™‡ÆØ‡Æ©‡Æ∞‡Øç ‡Æ™‡ØÜ‡ÆØ‡Æ∞‡Øç',
        'login_password': '‡Æï‡Æü‡Æµ‡ØÅ‡Æö‡Øç‡Æö‡Øä‡Æ≤‡Øç',
        'login_btn': '‡Æâ‡Æ≥‡Øç‡Æ®‡ØÅ‡Æ¥‡Øà',
        'register_fullname': '‡ÆÆ‡ØÅ‡Æ¥‡ØÅ ‡Æ™‡ØÜ‡ÆØ‡Æ∞‡Øç',
        'register_email': '‡ÆÆ‡Æø‡Æ©‡Øç‡Æ©‡Æû‡Øç‡Æö‡Æ≤‡Øç',
        'register_phone': '‡Æ§‡Øä‡Æ≤‡Øà‡Æ™‡Øá‡Æö‡Æø',
        'register_username': '‡Æ™‡ÆØ‡Æ©‡Æ∞‡Øç ‡Æ™‡ØÜ‡ÆØ‡Æ∞‡Øç',
        'register_password': '‡Æï‡Æü‡Æµ‡ØÅ‡Æö‡Øç‡Æö‡Øä‡Æ≤‡Øç',
        'register_confirmpw': '‡Æï‡Æü‡Æµ‡ØÅ‡Æö‡Øç‡Æö‡Øä‡Æ≤‡Øç‡Æ≤‡Øà ‡Æâ‡Æ±‡ØÅ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡Æµ‡ØÅ‡ÆÆ‡Øç',
        'register_btn': '‡Æ™‡Æ§‡Æø‡Æµ‡ØÅ',
        'buyorsell_buy': '‡Æµ‡Ææ‡Æô‡Øç‡Æï ‡Æö‡ØÜ‡Æ≤‡Øç‡Æ≤‡Æµ‡ØÅ‡ÆÆ‡Øç',
        'buyorsell_sell': '‡Æµ‡Æø‡Æ±‡Øç‡Æï ‡Æö‡ØÜ‡Æ≤‡Øç‡Æ≤‡Æµ‡ØÅ‡ÆÆ‡Øç',
        'payment_card': '‡ÆÖ‡Æü‡Øç‡Æü‡Øà ‡Æé‡Æ£‡Øç',
        'payment_expiry': '‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø ‡Æ§‡Øá‡Æ§‡Æø',
        'payment_cvv': 'CVV',
        'payment_btn': '‡Æï‡Æü‡Øç‡Æü‡Æ£‡ÆÆ‡Øç ‡Æö‡ØÜ‡Æ≤‡ØÅ‡Æ§‡Øç‡Æ§‡Æµ‡ØÅ‡ÆÆ‡Øç',
        'sell_crop': '‡Æ™‡ÆØ‡Æø‡Æ∞‡Øç ‡Æ™‡ØÜ‡ÆØ‡Æ∞‡Øç',
        'sell_qty': '‡ÆÖ‡Æ≥‡Æµ‡ØÅ (‡Æï‡Æø‡Æ≤‡Øã)',
        'sell_price': '‡Æµ‡Æø‡Æ≤‡Øà (‡Æí‡Æ∞‡ØÅ ‡Æï‡Æø‡Æ≤‡Øã, MSP-‡Æê ‡Æµ‡Æø‡Æü ‡ÆÖ‡Æ§‡Æø‡Æï‡ÆÆ‡Øç)',
        'sell_img': '‡Æ™‡ÆØ‡Æø‡Æ∞‡Øç ‡Æ™‡Æü‡Æ§‡Øç‡Æ§‡Øà ‡Æ™‡Æ§‡Æø‡Æµ‡Øá‡Æ±‡Øç‡Æ±‡Æµ‡ØÅ‡ÆÆ‡Øç',
        'sell_btn': '‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà‡Æï‡Øç‡Æï‡ØÅ ‡Æ™‡Æü‡Øç‡Æü‡Æø‡ÆØ‡Æ≤‡Æø‡Æü‡Æµ‡ØÅ‡ÆÆ‡Øç',
        'output': '‡Æµ‡ØÜ‡Æ≥‡Æø‡ÆØ‡ØÄ‡Æü‡ØÅ',
        'context': 'Q&A-‡Æï‡Øç‡Æï‡ØÅ ‡Æö‡ØÇ‡Æ¥‡Æ≤‡Øç ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æø‡Æü‡Æµ‡ØÅ‡ÆÆ‡Øç',
        'enter_context': 'Q&A-‡Æï‡Øç‡Æï‡ØÅ ‡Æö‡ØÇ‡Æ¥‡Æ≤‡Øà ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æø‡Æü‡Æµ‡ØÅ‡ÆÆ‡Øç.',
        'agribot_title': "ü§ñ AgriBot - Your Futuristic Agricultural Assistant",
        'agribot_greeting': "Hello! I'm AgriBot. How can I assist you with your farm today?",
        'agribot_input_placeholder': "Type your message here...",
        'agribot_attach_image': "Attach image (optional)",
        'send': "Send",
        'show_history': "Show Conversation History",
        'you': "You",
        'agribot': "AgriBot",
        'analytics_dashboard': "üìä Analytics Dashboard",
        'analytics_total_questions': "Total AgriBot Questions Asked",
        'analytics_common_crops': "Most Common Crops Discussed",
        'analytics_disease_trends': "Disease Diagnosis Trends",
        'analytics_engagement': "User Engagement Over Time",
        'analytics_pie_types': "Pie Chart of Question Types",
        'analytics_recent_log': "Recent Activity Log",
        'analytics_upload_csv': "Upload a CSV file for visualization",
        'analytics_no_data': "No chat data to display.",
        'analytics_no_conversations': "No conversation data found.",
        'analytics_no_keywords': "No crop keywords found in chats.",
        'analytics_no_disease': "No disease keywords found in chats.",
        'analytics_no_types': "No question type data found.",
        'analytics_info_upload': "If you want to visualize other CSV/statistics, upload them below:",
    },
    'kn': {
        'app_title': "üåæ ‡≤ï‡≥É‡≤∑‡≤ø ‡≤∏‡≤π‡≤æ‡≤Ø: ‡≤é‡≤ê ‡≤ö‡≤æ‡≤≤‡≤ø‡≤§ ‡≤ï‡≥É‡≤∑‡≤ø ‡≤∏‡≤π‡≤æ‡≤Ø‡≤ï üåæ",
        'home': "‡≤Æ‡≥Å‡≤ñ‡≤™‡≥Å‡≤ü",
        'recommendations': "‡≤∂‡≤ø‡≤´‡≤æ‡≤∞‡≤∏‡≥Å‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤™‡≤°‡≥Ü‡≤Ø‡≤ø‡≤∞‡≤ø",
        'diagnosis': "‡≤é‡≤ê ‡≤∞‡≥ã‡≤ó ‡≤®‡≤ø‡≤∞‡≥ç‡≤ß‡≤æ‡≤∞",
        'validation': "‡≤∞‡≥à‡≤§ ‡≤¶‡≥É‡≤¢‡≥Ä‡≤ï‡≤∞‡≤£",
        'language': "‡≤≠‡≤æ‡≤∑‡≥Ü",
        'select_language': "‡≤≠‡≤æ‡≤∑‡≥Ü‡≤Ø‡≤®‡≥ç‡≤®‡≥Å ‡≤Ü‡≤Ø‡≥ç‡≤ï‡≥Ü‡≤Æ‡≤æ‡≤°‡≤ø",
        'weather': "‡≤π‡≤µ‡≤æ‡≤Æ‡≤æ‡≤® ‡≤Æ‡≥Å‡≤®‡≥ç‡≤∏‡≥Ç‡≤ö‡≤®‡≥Ü",
        'input_options': "‡≤á‡≤®‡≥ç‚Äå‡≤™‡≥Å‡≤ü‡≥ç ‡≤Ü‡≤Ø‡≥ç‡≤ï‡≥Ü‡≤ó‡≤≥‡≥Å",
        'image_input': "‡≤ö‡≤ø‡≤§‡≥ç‡≤∞‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤Ö‡≤™‡≥ç‚Äå‡≤≤‡≥ã‡≤°‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø",
        'voice_input': "‡≤ß‡≥ç‡≤µ‡≤®‡≤ø ‡≤á‡≤®‡≥ç‚Äå‡≤™‡≥Å‡≤ü‡≥ç",
        'text_input': "‡≤™‡≤†‡≥ç‡≤Ø ‡≤á‡≤®‡≥ç‚Äå‡≤™‡≥Å‡≤ü‡≥ç",
        'submit': "‡≤∏‡≤≤‡≥ç‡≤≤‡≤ø‡≤∏‡≥Å",
        'severity': "‡≤∞‡≥ã‡≤ó ‡≤§‡≥Ä‡≤µ‡≥ç‡≤∞‡≤§‡≥Ü ‡≤Ö‡≤Ç‡≤¶‡≤æ‡≤ú‡≥Å",
        'correction': "‡≤∞‡≥à‡≤§ ‡≤§‡≤ø‡≤¶‡≥ç‡≤¶‡≥Å‡≤™‡≤°‡≤ø",
        'enter_farm_data': "‡≤π‡≤≥‡≥ç‡≤≥‡≤ø ‡≤°‡≥á‡≤ü‡≤æ ‡≤®‡≤Æ‡≥Ç‡≤¶‡≤ø‡≤∏‡≤ø",
        'farm_id': "‡≤π‡≤≥‡≥ç‡≤≥‡≤ø ‡≤ê‡≤°‡≤ø",
        'soil_ph': "‡≤Æ‡≤£‡≥ç‡≤£‡≥Å ‡≤™‡≤ø‡≤π‡≥Ü‡≤ö‡≥ç ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø",
        'soil_moisture': "‡≤Æ‡≤£‡≥ç‡≤£‡≥Å ‡≤§‡≥á‡≤µ‡≤æ‡≤Ç‡≤∂ (%)",
        'temperature': "‡≤§‡≤æ‡≤™‡≤Æ‡≤æ‡≤® (¬∞C)",
        'rainfall': "‡≤Æ‡≤≥‡≥Ü (‡≤Æ‡≤ø‡≤Æ‡≥Ä)",
        'crop_type': "‡≤¨‡≥Ü‡≤≥‡≥Ü ‡≤™‡≥ç‡≤∞‡≤ï‡≤æ‡≤∞",
        'fertilizer_usage': "‡≤∏‡≤∞‡≥ç‡≤ú‡≤ø ‡≤¨‡≤≥‡≤ï‡≥Ü (‡≤ï‡≥Ü‡≤ú‡≤ø)",
        'pesticide_usage': "‡≤π‡≤æ‡≤®‡≤ø‡≤ï‡≤æ‡≤∞‡≤ï ‡≤¨‡≤≥‡≤ï‡≥Ü (‡≤ï‡≥Ü‡≤ú‡≤ø)",
        'crop_yield': "‡≤¨‡≥Ü‡≤≥‡≥Ü ‡≤â‡≤§‡≥ç‡≤™‡≤æ‡≤¶‡≤®‡≥Ü (‡≤ü‡≤®‡≥ç)",
        'sustainability_score': "‡≤∏‡≥ç‡≤•‡≤ø‡≤∞‡≤§‡≥Ü ‡≤Ö‡≤Ç‡≤ï‡≤ó‡≤≥‡≥Å",
        'select_crop': "‡≤Æ‡≤æ‡≤∞‡±Å‡≤ï‡≤ü‡≥ç‡≤ü‡≥Ü/‡≤π‡≤µ‡≤æ‡≤Æ‡≤æ‡≤®/‡≤∏‡≥ç‡≤•‡≤ø‡≤∞‡≤§‡≥Ü ‡≤∏‡≤≤‡≤π‡≥Ü‡≤ó‡≥Ü ‡≤¨‡≥Ü‡≤≥‡≥Ü ‡≤Ü‡≤Ø‡≥ç‡≤ï‡≥Ü‡≤Æ‡≤æ‡≤°‡≤ø",
        'get_recommendations': "‡≤∂‡≤ø‡≤´‡≤æ‡≤∞‡≤∏‡≥Å‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤™‡≤°‡≥Ü‡≤Ø‡≤ø‡≤∞‡≤ø",
        'soil_recommendations': "üßæ ‡≤Æ‡≤£‡≥ç‡≤£‡≥Å ‡≤∂‡≤ø‡≤´‡≤æ‡≤∞‡≤∏‡≥Å‡≤ó‡≤≥‡≥Å",
        'market_trends': "üìà ‡≤Æ‡≤æ‡≤∞‡±Å‡≤ï‡≤ü‡≥ç‡≤ü‡≥Ü ‡≤™‡≥ç‡≤∞‡≤µ‡≥É‡≤§‡≥ç‡≤§‡≤ø‡≤ó‡≤≥‡≥Å",
        'weather_forecast': "üå§Ô∏è ‡≤π‡≤µ‡≤æ‡≤Æ‡≤æ‡≤® ‡≤Æ‡≥Å‡≤®‡≥ç‡≤∏‡≥Ç‡≤ö‡≤®‡≥Ü",
        'sustainable_practices': "üå± ‡≤∏‡≥ç‡≤•‡≤ø‡≤∞ ‡≤Ö‡≤≠‡≥ç‡≤Ø‡≤æ‡≤∏‡≤ó‡≤≥‡≥Å",
        'ai_diagnosis': "‡≤é‡≤ê ‡≤®‡≤ø‡≤∞‡≥ç‡≤ß‡≤æ‡≤∞ ‡≤´‡≤≤‡≤ø‡≤§‡≤æ‡≤Ç‡≤∂",
        'severity_result': "‡≤Ö‡≤Ç‡≤¶‡≤æ‡≤ú‡≥Å ‡≤§‡≥Ä‡≤µ‡≥ç‡≤∞‡≤§‡≥Ü",
        'validation_prompt': "‡≤Æ‡≥á‡≤≤‡≤ø‡≤® ‡≤Æ‡≤æ‡≤π‡≤ø‡≤§‡≤ø ‡≤∏‡≤∞‡≤ø‡≤Ø‡≥á?",
        'correction_prompt': "‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å ‡≤∏‡≤∞‡≤ø‡≤Ø‡≤æ‡≤¶ ‡≤®‡≤ø‡≤∞‡≥ç‡≤ß‡≤æ‡≤∞‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤®‡≥Ä‡≤°‡≤ø:",
        'thank_you': "‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤™‡≥ç‡≤∞‡≤§‡≤ø‡≤ï‡≥ç‡≤∞‡≤ø‡≤Ø‡≥Ü‡≤ó‡≥Ü ‡≤ß‡≤®‡≥ç‡≤Ø‡≤µ‡≤æ‡≤¶‡≤ó‡≤≥‡≥Å!",
        'back_home': "‡≤Æ‡≥Å‡≤ñ‡≤™‡≥Å‡≤ü‡≤ï‡≥ç‡≤ï‡≥Ü ‡≤π‡≤ø‡≤Ç‡≤§‡≤ø‡≤∞‡≥Å‡≤ó‡≤ø",
        'growth_diary': "‡≤µ‡≥É‡≤¶‡≥ç‡≤ß‡≤ø ‡≤¶‡≤ø‡≤®‡≤ö‡≤∞‡≤ø",
        'add_entry': "‡≤π‡≥ä‡≤∏ ‡≤¶‡≤æ‡≤ñ‡≤≤‡≥Ü‡≤Ø‡≤®‡≥ç‡≤®‡≥Å ‡≤∏‡≥á‡≤∞‡≤ø‡≤∏‡≤ø",
        'diary_log': "‡≤¶‡≤ø‡≤®‡≤ö‡≤∞‡≤ø ‡≤¶‡≤æ‡≤ñ‡≤≤‡≥Ü",
        'crop': "‡≤¨‡≥Ü‡≤≥‡≥Ü",
        'notes': "‡≤ü‡≤ø‡≤™‡≥ç‡≤™‡≤£‡≤ø‡≤ó‡≤≥‡≥Å",
        'save_entry': "‡≤¶‡≤æ‡≤ñ‡≤≤‡≥Ü ‡≤â‡≤≥‡≤ø‡≤∏‡≤ø",
        'entry_saved': "‡≤¶‡≤æ‡≤ñ‡≤≤‡≥Ü ‡≤â‡≤≥‡≤ø‡≤∏‡≤≤‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü!",
        'knowledge_sharing': "‡≤ú‡≥ç‡≤û‡≤æ‡≤® ‡≤π‡≤Ç‡≤ö‡≤ø‡≤ï‡≥Ü",
        'start_discussion': "‡≤π‡≥ä‡≤∏ ‡≤ö‡≤∞‡≥ç‡≤ö‡≥Ü ‡≤™‡≥ç‡≤∞‡≤æ‡≤∞‡≤Ç‡≤≠‡≤ø‡≤∏‡≤ø",
        'all_discussions': "‡≤é‡≤≤‡≥ç‡≤≤‡≤æ ‡≤ö‡≤∞‡≥ç‡≤ö‡≥Ü‡≤ó‡≤≥‡≥Å",
        'post_thread': "‡≤•‡≥ç‡≤∞‡≥Ü‡≤°‡≥ç ‡≤™‡≥ã‡≤∏‡≥ç‡≤ü‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø",
        'reply': "‡≤™‡≥ç‡≤∞‡≤§‡≥ç‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤∞",
        'thread_posted': "‡≤•‡≥ç‡≤∞‡≥Ü‡≤°‡≥ç ‡≤™‡≥ã‡≤∏‡≥ç‡≤ü‡≥ç ‡≤Æ‡≤æ‡≤°‡≤≤‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü!",
        'reply_posted': "‡≤™‡≥ç‡≤∞‡≤§‡≥ç‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤∞ ‡≤™‡≥ã‡≤∏‡≥ç‡≤ü‡≥ç ‡≤Æ‡≤æ‡≤°‡≤≤‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü!",
        'soil_health': "‡≤Æ‡≤£‡≥ç‡≤£‡≥Å ‡≤Ü‡≤∞‡≥ã‡≤ó‡≥ç‡≤Ø ‡≤∏‡≥ç‡≤ï‡≥ç‡≤Ø‡≤æ‡≤®‡≤ø‡≤Ç‡≤ó‡≥ç",
        'add_soil_test': "‡≤π‡≥ä‡≤∏ ‡≤Æ‡≤£‡≥ç‡≤£‡≥Å ‡≤™‡≤∞‡≥Ä‡≤ï‡≥ç‡≤∑‡≥Ü ‡≤∏‡≥á‡≤∞‡≤ø‡≤∏‡≤ø",
        'soil_test_log': "‡≤Æ‡≤£‡≥ç‡≤£‡≥Å ‡≤™‡≤∞‡≥Ä‡≤ï‡≥ç‡≤∑‡≥Ü ‡≤¶‡≤æ‡≤ñ‡≤≤‡≥Ü",
        'save_soil_test': "‡≤Æ‡≤£‡≥ç‡≤£‡≥Å ‡≤™‡≤∞‡≥Ä‡≤ï‡≥ç‡≤∑‡≥Ü ‡≤â‡≤≥‡≤ø‡≤∏‡≤ø",
        'soil_test_saved': "‡≤Æ‡≤£‡≥ç‡≤£‡≥Å ‡≤™‡≤∞‡≥Ä‡≤ï‡≥ç‡≤∑‡≥Ü ‡≤â‡≤≥‡≤ø‡≤∏‡≤≤‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü!",
        'heatmaps': "‡≤≤‡≥à‡≤µ‡≥ç ‡≤ï‡≥É‡≤∑‡≤ø ‡≤π‡≥Ä‡≤ü‡≥ç‡≤Æ‡≥ç‡≤Ø‡≤æ‡≤™‡≥ç‡≤∏‡≥ç ‡≤Æ‡≤§‡≥ç‡≤§‡≥Å ‡≤∞‡≥ã‡≤ó ‡≤µ‡≥Ä‡≤ï‡≥ç‡≤∑‡≤£‡≥Ü",
        'outbreak_map': "‡≤∞‡≥ã‡≤ó ‡≤µ‡≥Ä‡≤ï‡≥ç‡≤∑‡≤£‡≤æ ‡≤®‡≤ï‡≥ç‡≤∑‡≥Ü",
        'no_geo_reports': "‡≤ú‡≤ø‡≤Ø‡≥ã-‡≤ü‡≥ç‡≤Ø‡≤æ‡≤ó‡≥ç‡≤°‡≥ç ‡≤µ‡≤∞‡≤¶‡≤ø‡≤ó‡≤≥‡≥Å ‡≤á‡≤≤‡≥ç‡≤≤.",
        'report_outbreak': "‡≤π‡≥ä‡≤∏ ‡≤∞‡≥ã‡≤ó‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤µ‡≤∞‡≤¶‡≤ø ‡≤Æ‡≤æ‡≤°‡≤ø",
        'submit_outbreak': "‡≤∞‡≥ã‡≤ó ‡≤µ‡≤∞‡≤¶‡≤ø ‡≤∏‡≤≤‡≥ç‡≤≤‡≤ø‡≤∏‡≤ø",
        'outbreak_reported': "‡≤∞‡≥ã‡≤ó ‡≤µ‡≤∞‡≤¶‡≤ø ‡≤∏‡≤≤‡≥ç‡≤≤‡≤ø‡≤∏‡≤≤‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü!",
        'khet_market': "‡≤ï‡≥É‡≤∑‡≤ø ‡≤Æ‡≤æ‡≤∞‡±Å‡≤ï‡≤ü‡≥ç‡≤ü‡≥Ü",
        'market_home': "‡≤Æ‡≥Å‡≤ñ‡≤™‡≥Å‡≤ü",
        'market_login': "‡≤≤‡≤æ‡≤ó‡≤ø‡≤®‡≥ç",
        'market_register': "‡≤®‡≥ã‡≤Ç‡≤¶‡≤£‡≤ø",
        'market_buyorsell': "‡≤ñ‡≤∞‡≥Ä‡≤¶‡≤ø/‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü",
        'market_buy': "‡≤ñ‡≤∞‡≥Ä‡≤¶‡≤ø",
        'market_checkout': "‡≤ö‡≥Ü‡≤ï‡≥ç‚Äå‡≤î‡≤ü‡≥ç",
        'market_payment': "‡≤™‡≤æ‡≤µ‡≤§‡≤ø",
        'market_orders': "‡≤Ü‡≤∞‡≥ç‡≤°‡≤∞‡≥ç‚Äå‡≤ó‡≤≥‡≥Å",
        'market_sell': "‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü",
        'market_selling_item': "‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü‡≤¶ ‡≤µ‡≤∏‡≥ç‡≤§‡≥Å",
        'login_username': "‡≤¨‡≤≥‡≤ï‡≥Ü‡≤¶‡≤æ‡≤∞ ‡≤π‡≥Ü‡≤∏‡≤∞‡≥Å",
        'login_password': "‡≤™‡≤æ‡≤∏‡≥ç‡≤µ‡≤∞‡≥ç‡≤°‡≥ç",
        'login_btn': "‡≤≤‡≤æ‡≤ó‡≤ø‡≤®‡≥ç",
        'register_fullname': "‡≤™‡≥Ç‡≤∞‡≥ç‡≤£ ‡≤π‡≥Ü‡≤∏‡≤∞‡≥Å",
        'register_email': "‡≤á‡≤Æ‡≥á‡≤≤‡≥ç",
        'register_phone': "‡≤´‡≥ã‡≤®‡≥ç",
        'register_username': "‡≤¨‡≤≥‡≤ï‡≥Ü‡≤¶‡≤æ‡≤∞ ‡≤π‡≥Ü‡≤∏‡≤∞‡≥Å",
        'register_password': "‡≤™‡≤æ‡≤∏‡≥ç‡≤µ‡≤∞‡≥ç‡≤°‡≥ç",
        'register_confirmpw': "‡≤™‡≤æ‡≤∏‡≥ç‡≤µ‡≤∞‡≥ç‡≤°‡≥ç ‡≤¶‡≥É‡≤¢‡≥Ä‡≤ï‡≤∞‡≤ø‡≤∏‡≤ø",
        'register_btn': "‡≤®‡≥ã‡≤Ç‡≤¶‡≤£‡≤ø",
        'buyorsell_buy': "‡≤ñ‡≤∞‡≥Ä‡≤¶‡≤ø‡≤ó‡≥Ü ‡≤π‡≥ã‡≤ó‡≤ø",
        'buyorsell_sell': "‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü‡≤ï‡≥ç‡≤ï‡≥Ü ‡≤π‡≥ã‡≤ó‡≤ø",
        'payment_card': "‡≤ï‡≤æ‡≤∞‡≥ç‡≤°‡≥ç ‡≤∏‡≤Ç‡≤ñ‡≥ç‡≤Ø‡≥Ü",
        'payment_expiry': "‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤µ ‡≤¶‡≤ø‡≤®‡≤æ‡≤Ç‡≤ï",
        'payment_cvv': "CVV",
        'payment_btn': "‡≤™‡≤æ‡≤µ‡≤§‡≤ø ‡≤Æ‡≤æ‡≤°‡≤ø",
        'sell_crop': "‡≤¨‡≥Ü‡≤≥‡≥Ü ‡≤π‡≥Ü‡≤∏‡≤∞‡≥Å",
        'sell_qty': "‡≤™‡≥ç‡≤∞‡≤Æ‡≤æ‡≤£ (‡≤ï‡≥Ü‡≤ú‡≤ø)",
        'sell_price': "‡≤¨‡≥Ü‡≤≤‡≥Ü (‡≤™‡≥ç‡≤∞‡≤§‡≤ø ‡≤ï‡≥Ü‡≤ú‡≤ø, MSP ‡≤ó‡≤ø‡≤Ç‡≤§ ‡≤π‡≥Ü‡≤ö‡≥ç‡≤ö‡≥Å)",
        'sell_img': "‡≤¨‡≥Ü‡≤≥‡≥Ü ‡≤ö‡≤ø‡≤§‡≥ç‡≤∞‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤Ö‡≤™‡≥ç‚Äå‡≤≤‡≥ã‡≤°‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø",
        'sell_btn': "‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü‡≤ï‡≥ç‡≤ï‡≥Ü ‡≤™‡≤ü‡≥ç‡≤ü‡≤ø ‡≤Æ‡≤æ‡≤°‡≤ø",
        'output': "‡≤î‡≤ü‡≥ç‚Äå‡≤™‡≥Å‡≤ü‡≥ç",
        'context': "Q&A ‡≤ó‡≥Ü ‡≤∏‡≤®‡≥ç‡≤®‡≤ø‡≤µ‡≥á‡≤∂‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤®‡≤Æ‡≥Ç‡≤¶‡≤ø‡≤∏‡≤ø",
        'enter_context': "‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å Q&A ‡≤ó‡≥Ü ‡≤∏‡≤®‡≥ç‡≤®‡≤ø‡≤µ‡≥á‡≤∂‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤®‡≤Æ‡≥Ç‡≤¶‡≤ø‡≤∏‡≤ø.",
        'agribot_title': "ü§ñ AgriBot - Your Futuristic Agricultural Assistant",
        'agribot_greeting': "Hello! I'm AgriBot. How can I assist you with your farm today?",
        'agribot_input_placeholder': "Type your message here...",
        'agribot_attach_image': "Attach image (optional)",
        'send': "Send",
        'show_history': "Show Conversation History",
        'you': "You",
        'agribot': "AgriBot",
        'analytics_dashboard': "üìä Analytics Dashboard",
        'analytics_total_questions': "Total AgriBot Questions Asked",
        'analytics_common_crops': "Most Common Crops Discussed",
        'analytics_disease_trends': "Disease Diagnosis Trends",
        'analytics_engagement': "User Engagement Over Time",
        'analytics_pie_types': "Pie Chart of Question Types",
        'analytics_recent_log': "Recent Activity Log",
        'analytics_upload_csv': "Upload a CSV file for visualization",
        'analytics_no_data': "No chat data to display.",
        'analytics_no_conversations': "No conversation data found.",
        'analytics_no_keywords': "No crop keywords found in chats.",
        'analytics_no_disease': "No disease keywords found in chats.",
        'analytics_no_types': "No question type data found.",
        'analytics_info_upload': "If you want to visualize other CSV/statistics, upload them below:",
    },
    'ml': {
        'app_title': "üåæ ‡¥ï‡µÉ‡¥∑‡¥ø‡¥∏‡¥ñ‡¥ø: ‡¥é‡¥ê ‡¥™‡µç‡¥∞‡¥µ‡µº‡¥§‡µç‡¥§‡¥ø‡¥§ ‡¥ï‡µÉ‡¥∑‡¥ø ‡¥∏‡¥π‡¥æ‡¥Ø‡¥ø üåæ",
        'home': "‡¥π‡µã‡¥Ç",
        'recommendations': "‡¥∂‡µÅ‡¥™‡¥æ‡µº‡¥∂‡¥ï‡µæ ‡¥®‡µá‡¥ü‡µÅ‡¥ï",
        'diagnosis': "‡¥é‡¥ê ‡¥∞‡µã‡¥ó ‡¥®‡¥ø‡µº‡¥£‡¥Ø‡¥Ç",
        'validation': "‡¥ï‡µº‡¥∑‡¥ï‡µª ‡¥∏‡µç‡¥•‡¥ø‡¥∞‡µÄ‡¥ï‡¥∞‡¥ø‡¥ï‡µç‡¥ï‡µΩ",
        'language': "‡¥≠‡¥æ‡¥∑",
        'select_language': "‡¥≠‡¥æ‡¥∑ ‡¥§‡¥ø‡¥∞‡¥û‡µç‡¥û‡µÜ‡¥ü‡µÅ‡¥ï‡µç‡¥ï‡µÅ‡¥ï",
        'weather': "‡¥ï‡¥æ‡¥≤‡¥æ‡¥µ‡¥∏‡µç‡¥• ‡¥™‡µç‡¥∞‡¥µ‡¥ö‡¥®‡¥Ç",
        'input_options': "‡¥á‡µª‡¥™‡µÅ‡¥ü‡µç‡¥ü‡µç ‡¥ì‡¥™‡µç‡¥∑‡¥®‡µÅ‡¥ï‡µæ",
        'image_input': "‡¥ö‡¥ø‡¥§‡µç‡¥∞‡¥Ç ‡¥Ö‡¥™‡µç‚Äå‡¥≤‡µã‡¥°‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï",
        'voice_input': "‡¥∂‡¥¨‡µç‡¥¶ ‡¥á‡µª‡¥™‡µÅ‡¥ü‡µç‡¥ü‡µç",
        'text_input': "‡¥ü‡µÜ‡¥ï‡µç‡¥∏‡µç‡¥±‡µç‡¥±‡µç ‡¥á‡µª‡¥™‡µÅ‡¥ü‡µç‡¥ü‡µç",
        'submit': "‡¥∏‡¥Æ‡µº‡¥™‡µç‡¥™‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï",
        'severity': "‡¥∞‡µã‡¥ó ‡¥ó‡µÅ‡¥∞‡µÅ‡¥§‡µç‡¥µ‡¥Ç ‡¥ï‡¥£‡¥ï‡µç‡¥ï‡¥æ‡¥ï‡µç‡¥ï‡µΩ",
        'correction': "‡¥ï‡µº‡¥∑‡¥ï‡µª ‡¥§‡¥ø‡¥∞‡µÅ‡¥§‡µç‡¥§‡µΩ",
        'enter_farm_data': "‡¥´‡¥æ‡¥Ç ‡¥°‡¥æ‡¥±‡µç‡¥± ‡¥®‡µΩ‡¥ï‡µÅ‡¥ï",
        'farm_id': "‡¥´‡¥æ‡¥Ç ‡¥ê‡¥°‡¥ø",
        'soil_ph': "‡¥Æ‡¥£‡µç‡¥£‡¥ø‡¥®‡µç‡¥±‡µÜ ‡¥™‡¥ø‡¥é‡¥ö‡µç‡¥ö‡µç ‡¥Æ‡µÇ‡¥≤‡µç‡¥Ø‡¥Ç",
        'soil_moisture': "‡¥Æ‡¥£‡µç‡¥£‡¥ø‡¥≤‡µÜ ‡¥à‡µº‡¥™‡µç‡¥™‡¥Ç (%)",
        'temperature': "‡¥§‡¥æ‡¥™‡¥®‡¥ø‡¥≤ (¬∞C)",
        'rainfall': "‡¥Æ‡¥¥ (‡¥Æ‡¥ø‡¥≤‡µç‡¥≤‡µÄ‡¥Æ‡µÄ‡¥±‡µç‡¥±‡µº)",
        'crop_type': "‡¥µ‡¥ø‡¥≥‡¥Ø‡µÅ‡¥ü‡µÜ ‡¥§‡¥∞‡¥Ç",
        'fertilizer_usage': "‡¥µ‡¥≥‡¥§‡µç‡¥§‡¥ø‡¥®‡µç‡¥±‡µÜ ‡¥â‡¥™‡¥Ø‡µã‡¥ó‡¥Ç (‡¥ï‡¥ø‡¥≤‡µã)",
        'pesticide_usage': " ‡¥ï‡µÄ‡¥ü‡¥®‡¥æ‡¥∂‡¥ø‡¥®‡¥ø ‡¥â‡¥™‡¥Ø‡µã‡¥ó‡¥Ç (‡¥ï‡¥ø‡¥≤‡µã)",
        'crop_yield': "‡¥µ‡¥ø‡¥≥‡¥Ø‡µÅ‡¥ü‡µÜ ‡¥µ‡¥ø‡¥≥‡¥µ‡µç (‡¥ü‡µ∫)",
        'sustainability_score': "‡¥∏‡µç‡¥•‡¥ø‡¥∞‡¥§ ‡¥∏‡µç‡¥ï‡µã‡µº",
        'select_crop': "‡¥Æ‡¥æ‡µº‡¥ï‡µç‡¥ï‡¥±‡µç‡¥±‡µç/‡¥ï‡¥æ‡¥≤‡¥æ‡¥µ‡¥∏‡µç‡¥•/‡¥∏‡µç‡¥•‡¥ø‡¥∞‡¥§ ‡¥®‡¥ø‡µº‡¥¶‡µç‡¥¶‡µá‡¥∂‡¥ô‡µç‡¥ô‡µæ‡¥ï‡µç‡¥ï‡µç ‡¥µ‡¥ø‡¥≥ ‡¥§‡¥ø‡¥∞‡¥û‡µç‡¥û‡µÜ‡¥ü‡µÅ‡¥ï‡µç‡¥ï‡µÅ‡¥ï",
        'get_recommendations': "‡¥∂‡µÅ‡¥™‡¥æ‡µº‡¥∂‡¥ï‡µæ ‡¥®‡µá‡¥ü‡µÅ‡¥ï",
        'soil_recommendations': "üßæ ‡¥Æ‡¥£‡µç‡¥£‡¥ø‡¥®‡µç‡¥±‡µÜ ‡¥∂‡µÅ‡¥™‡¥æ‡µº‡¥∂‡¥ï‡µæ",
        'market_trends': "üìà ‡¥Æ‡¥æ‡µº‡¥ï‡µç‡¥ï‡¥±‡µç‡¥±‡µç ‡¥ü‡µç‡¥∞‡µÜ‡µª‡¥°‡µÅ‡¥ï‡µæ",
        'weather_forecast': "üå§Ô∏è ‡¥ï‡¥æ‡¥≤‡¥æ‡¥µ‡¥∏‡µç‡¥• ‡¥™‡µç‡¥∞‡¥µ‡¥ö‡¥®‡¥Ç",
        'sustainable_practices': "üå± ‡¥∏‡µç‡¥•‡¥ø‡¥∞‡¥§‡¥Ø‡µÅ‡¥≥‡µç‡¥≥ ‡¥∞‡µÄ‡¥§‡¥ø‡¥ï‡µæ",
        'ai_diagnosis': "‡¥é‡¥ê ‡¥®‡¥ø‡µº‡¥£‡¥Ø ‡¥´‡¥≤‡¥Ç",
        'severity_result': "‡¥ï‡¥£‡¥ï‡µç‡¥ï‡¥æ‡¥ï‡µç‡¥ï‡¥ø‡¥Ø ‡¥ó‡µÅ‡¥∞‡µÅ‡¥§‡µç‡¥µ‡¥Ç",
        'validation_prompt': "‡¥Æ‡µÅ‡¥ï‡¥≥‡¥ø‡µΩ ‡¥ï‡¥æ‡¥£‡¥ø‡¥ö‡µç‡¥ö ‡¥µ‡¥ø‡¥µ‡¥∞‡¥ô‡µç‡¥ô‡µæ ‡¥∂‡¥∞‡¥ø‡¥Ø‡¥æ‡¥£‡µã?",
        'correction_prompt': "‡¥∂‡¥∞‡¥ø‡¥Ø‡¥æ‡¥Ø ‡¥®‡¥ø‡µº‡¥£‡¥Ø‡¥Ç ‡¥®‡µΩ‡¥ï‡µÅ‡¥ï:",
        'thank_you': "‡¥®‡¥ø‡¥ô‡µç‡¥ô‡¥≥‡µÅ‡¥ü‡µÜ ‡¥Ö‡¥≠‡¥ø‡¥™‡µç‡¥∞‡¥æ‡¥Ø‡¥§‡µç‡¥§‡¥ø‡¥®‡µç ‡¥®‡¥®‡µç‡¥¶‡¥ø!",
        'back_home': "‡¥π‡µã‡¥Ç‡¥≤‡µá‡¥ï‡µç‡¥ï‡µç ‡¥Æ‡¥ü‡¥ô‡µç‡¥ô‡µÅ‡¥ï",
        'growth_diary': '‡¥µ‡¥≥‡µº‡¥ö‡µç‡¥ö‡¥æ ‡¥°‡¥Ø‡¥±‡¥ø',
        'add_entry': '‡¥™‡µÅ‡¥§‡¥ø‡¥Ø ‡¥é‡µª‡¥ü‡µç‡¥∞‡¥ø ‡¥ö‡µá‡µº‡¥ï‡µç‡¥ï‡µÅ‡¥ï',
        'diary_log': '‡¥°‡¥Ø‡¥±‡¥ø ‡¥≤‡µã‡¥ó‡µç',
        'crop': '‡¥µ‡¥ø‡¥≥',
        'notes': '‡¥ï‡µÅ‡¥±‡¥ø‡¥™‡µç‡¥™‡µÅ‡¥ï‡µæ',
        'save_entry': '‡¥é‡µª‡¥ü‡µç‡¥∞‡¥ø ‡¥∏‡¥Ç‡¥∞‡¥ï‡µç‡¥∑‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï',
        'entry_saved': '‡¥é‡µª‡¥ü‡µç‡¥∞‡¥ø ‡¥∏‡¥Ç‡¥∞‡¥ï‡µç‡¥∑‡¥ø‡¥ö‡µç‡¥ö‡µÅ!',
        'knowledge_sharing': '‡¥Ö‡¥±‡¥ø‡¥µ‡µç ‡¥™‡¥ô‡µç‡¥ï‡¥ø‡¥ü‡µΩ',
        'start_discussion': '‡¥™‡µÅ‡¥§‡¥ø‡¥Ø ‡¥ö‡µº‡¥ö‡µç‡¥ö ‡¥Ü‡¥∞‡¥Ç‡¥≠‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï',
        'all_discussions': '‡¥é‡¥≤‡µç‡¥≤‡¥æ ‡¥ö‡µº‡¥ö‡µç‡¥ö‡¥ï‡¥≥‡µÅ‡¥Ç',
        'post_thread': '‡¥§‡µç‡¥∞‡µÜ‡¥°‡µç ‡¥™‡µã‡¥∏‡µç‡¥±‡µç‡¥±‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï',
        'reply': '‡¥Æ‡¥±‡µÅ‡¥™‡¥ü‡¥ø',
        'thread_posted': '‡¥§‡µç‡¥∞‡µÜ‡¥°‡µç ‡¥™‡µã‡¥∏‡µç‡¥±‡µç‡¥±‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥§‡µÅ!',
        'reply_posted': '‡¥Æ‡¥±‡µÅ‡¥™‡¥ü‡¥ø ‡¥™‡µã‡¥∏‡µç‡¥±‡µç‡¥±‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥§‡µÅ!',
        'soil_health': '‡¥Æ‡¥£‡µç‡¥£‡¥ø‡¥®‡µç‡¥±‡µÜ ‡¥Ü‡¥∞‡µã‡¥ó‡µç‡¥Ø ‡¥∏‡µç‡¥ï‡¥æ‡¥®‡¥ø‡¥Ç‡¥ó‡µç',
        'add_soil_test': '‡¥™‡µÅ‡¥§‡¥ø‡¥Ø ‡¥Æ‡¥£‡µç‡¥£‡µç ‡¥™‡¥∞‡¥ø‡¥∂‡µã‡¥ß‡¥® ‡¥ö‡µá‡µº‡¥ï‡µç‡¥ï‡µÅ‡¥ï',
        'soil_test_log': '‡¥Æ‡¥£‡µç‡¥£‡µç ‡¥™‡¥∞‡¥ø‡¥∂‡µã‡¥ß‡¥® ‡¥≤‡µã‡¥ó‡µç',
        'save_soil_test': '‡¥Æ‡¥£‡µç‡¥£‡µç ‡¥™‡¥∞‡¥ø‡¥∂‡µã‡¥ß‡¥® ‡¥∏‡¥Ç‡¥∞‡¥ï‡µç‡¥∑‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï',
        'soil_test_saved': '‡¥Æ‡¥£‡µç‡¥£‡µç ‡¥™‡¥∞‡¥ø‡¥∂‡µã‡¥ß‡¥® ‡¥∏‡¥Ç‡¥∞‡¥ï‡µç‡¥∑‡¥ø‡¥ö‡µç‡¥ö‡µÅ!',
        'heatmaps': '‡¥≤‡µà‡¥µ‡µç ‡¥ï‡µÉ‡¥∑‡¥ø ‡¥π‡µÄ‡¥±‡µç‡¥±‡µç‚Äå‡¥Æ‡¥æ‡¥™‡µç‡¥™‡µÅ‡¥ï‡¥≥‡µÅ‡¥Ç ‡¥∞‡µã‡¥ó ‡¥µ‡µç‡¥Ø‡¥æ‡¥™‡¥®‡¥µ‡µÅ‡¥Ç',
        'outbreak_map': '‡¥∞‡µã‡¥ó ‡¥µ‡µç‡¥Ø‡¥æ‡¥™‡¥® ‡¥Æ‡¥æ‡¥™‡µç‡¥™‡µç',
        'no_geo_reports': '‡¥ú‡¥ø‡¥Ø‡µã-‡¥ü‡¥æ‡¥ó‡µç‡¥°‡µç ‡¥±‡¥ø‡¥™‡µç‡¥™‡µã‡µº‡¥ü‡µç‡¥ü‡µÅ‡¥ï‡µæ ‡¥á‡¥≤‡≥ç‡¥≤.',
        'report_outbreak': '‡¥™‡µÅ‡¥§‡¥ø‡¥Ø ‡¥∞‡µã‡¥ó‡¥Ç ‡¥±‡¥ø‡¥™‡µç‡¥™‡µã‡µº‡¥ü‡µç‡¥ü‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï',
        'submit_outbreak': '‡¥∞‡µã‡¥ó ‡¥±‡¥ø‡¥™‡µç‡¥™‡µã‡µº‡¥ü‡µç‡¥ü‡µç ‡¥∏‡¥Æ‡µº‡¥™‡µç‡¥™‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï',
        'outbreak_reported': '‡¥∞‡µã‡¥ó ‡¥±‡¥ø‡¥™‡µç‡¥™‡µã‡µº‡¥ü‡µç‡¥ü‡µç ‡¥∏‡¥Æ‡µº‡¥™‡µç‡¥™‡¥ø‡¥ö‡µç‡¥ö‡µÅ!',
        'khet_market': '‡¥ï‡µÉ‡¥∑‡¥ø ‡¥Æ‡¥æ‡µº‡¥ï‡µç‡¥ï‡¥±‡µç‡¥±‡µç',
        'market_home': '‡¥π‡µã‡¥Ç',
        'market_login': '‡¥≤‡µã‡¥ó‡¥ø‡µª',
        'market_register': '‡¥∞‡¥ú‡¥ø‡¥∏‡µç‡¥±‡µç‡¥±‡µº',
        'market_buyorsell': '‡¥µ‡¥æ‡¥ô‡µç‡¥ô‡µÅ‡¥ï/‡¥µ‡¥ø‡µΩ‡¥ï‡µç‡¥ï‡µÅ‡¥ï',
        'market_buy': '‡¥µ‡¥æ‡¥ô‡µç‡¥ô‡µÅ‡¥ï',
        'market_checkout': '‡¥ö‡µÜ‡¥ï‡µç‡¥ï‡µç‚Äå‡¥î‡¥ü‡µç‡¥ü‡µç',
        'market_payment': '‡¥™‡µá‡¥Ø‡µç‡¥Æ‡µÜ‡¥®‡µç‡¥±‡µç',
        'market_orders': '‡¥ì‡µº‡¥°‡¥±‡µÅ‡¥ï‡µæ',
        'market_sell': '‡¥µ‡¥ø‡µΩ‡¥ï‡µç‡¥ï‡µÅ‡¥ï',
        'market_selling_item': '‡¥µ‡¥ø‡µΩ‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥® ‡¥á‡¥®‡¥Ç',
        'login_username': '‡¥â‡¥™‡¥Ø‡µã‡¥ï‡µç‡¥§‡µÉ‡¥®‡¥æ‡¥Æ‡¥Ç',
        'login_password': '‡¥™‡¥æ‡¥∏‡µç‚Äå‡¥µ‡µá‡¥°‡µç',
        'login_btn': '‡¥≤‡µã‡¥ó‡¥ø‡µª',
        'register_fullname': '‡¥™‡µÇ‡µº‡¥£‡µç‡¥£‡¥®‡¥æ‡¥Æ‡¥Ç',
        'register_email': '‡¥á‡¥Æ‡µÜ‡¥Ø‡¥ø‡µΩ',
        'register_phone': '‡¥´‡µã‡µ∫',
        'register_username': '‡¥â‡¥™‡¥Ø‡µã‡¥ï‡µç‡¥§‡µÉ‡¥®‡¥æ‡¥Æ‡¥Ç',
        'register_password': '‡¥™‡¥æ‡¥∏‡µç‚Äå‡¥µ‡µá‡¥°‡µç',
        'register_confirmpw': '‡¥™‡¥æ‡¥∏‡µç‚Äå‡¥µ‡µá‡¥°‡µç ‡¥∏‡µç‡¥•‡¥ø‡¥∞‡µÄ‡¥ï‡¥∞‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï',
        'register_btn': '‡¥∞‡¥ú‡¥ø‡¥∏‡µç‡¥±‡µç‡¥±‡µº',
        'buyorsell_buy': '‡¥µ‡¥æ‡¥ô‡µç‡¥ô‡¥æ‡µª ‡¥™‡µã‡¥ï‡µÅ‡¥ï',
        'buyorsell_sell': '‡¥µ‡¥ø‡µΩ‡¥ï‡µç‡¥ï‡¥æ‡µª ‡¥™‡µã‡¥ï‡µÅ‡¥ï',
        'payment_card': '‡¥ï‡¥æ‡µº‡¥°‡µç ‡¥®‡¥Æ‡µç‡¥™‡µº',
        'payment_expiry': '‡¥ï‡¥æ‡¥≤‡¥æ‡¥µ‡¥ß‡¥ø ‡¥§‡µÄ‡¥Ø‡¥§‡¥ø',
        'payment_cvv': 'CVV',
        'payment_btn': '‡¥™‡µá‡¥Ø‡µç‡¥Æ‡µÜ‡¥®‡µç‡¥±‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï',
        'sell_crop': '‡¥µ‡¥ø‡¥≥‡¥Ø‡µÅ‡¥ü‡µÜ ‡¥™‡µá‡¥∞‡µç',
        'sell_qty': '‡¥Ö‡¥≥‡¥µ‡µç (‡¥ï‡¥ø‡¥≤‡µã)',
        'sell_price': '‡¥µ‡¥ø‡¥≤ (‡¥ì‡¥∞‡µã ‡¥ï‡¥ø‡¥≤‡µã‡¥Ø‡µç‡¥ï‡µç‡¥ï‡µÅ‡¥Ç, MSP-‡¥®‡µá‡¥ï‡µç‡¥ï‡¥æ‡µæ ‡¥ï‡µÇ‡¥ü‡µÅ‡¥§‡¥≤‡¥æ‡¥Ø‡¥ø‡¥∞‡¥ø‡¥ï‡µç‡¥ï‡¥£‡¥Ç)',
        'sell_img': '‡¥µ‡¥ø‡¥≥‡¥Ø‡µÅ‡¥ü‡µÜ ‡¥ö‡¥ø‡¥§‡µç‡¥∞‡¥Ç ‡¥Ö‡¥™‡µç‚Äå‡¥≤‡µã‡¥°‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï',
        'sell_btn': '‡¥µ‡¥ø‡µΩ‡¥™‡µç‡¥™‡¥®‡¥Ø‡µç‡¥ï‡µç‡¥ï‡µç ‡¥™‡¥ü‡µç‡¥ü‡¥ø‡¥ï‡¥Ø‡¥ø‡¥ü‡µÅ‡¥ï',
        'output': '‡¥î‡¥ü‡µç‡¥ü‡µç‚Äå‡¥™‡µÅ‡¥ü‡µç‡¥ü‡µç',
        'context': 'Q&A-‡¥Ø‡µç‡¥ï‡µç‡¥ï‡µç ‡¥ï‡µã‡µ∫‡¥ü‡µÜ‡¥ï‡µç‡¥∏‡µç‡¥±‡µç‡¥±‡µç ‡¥®‡µΩ‡¥ï‡µÅ‡¥ï',
        'enter_context': '‡¥¶‡¥Ø‡¥µ‡¥æ‡¥Ø‡¥ø Q&A-‡¥Ø‡µç‡¥ï‡µç‡¥ï‡µç ‡¥ï‡µã‡µ∫‡¥ü‡µÜ‡¥ï‡µç‡¥∏‡µç‡¥±‡µç‡¥±‡µç ‡¥®‡µΩ‡¥ï‡µÅ‡¥ï.',
        'agribot_title': "ü§ñ AgriBot - Your Futuristic Agricultural Assistant",
        'agribot_greeting': "Hello! I'm AgriBot. How can I assist you with your farm today?",
        'agribot_input_placeholder': "Type your message here...",
        'agribot_attach_image': "Attach image (optional)",
        'send': "Send",
        'show_history': "Show Conversation History",
        'you': "You",
        'agribot': "AgriBot",
        'analytics_dashboard': "üìä Analytics Dashboard",
        'analytics_total_questions': "Total AgriBot Questions Asked",
        'analytics_common_crops': "Most Common Crops Discussed",
        'analytics_disease_trends': "Disease Diagnosis Trends",
        'analytics_engagement': "User Engagement Over Time",
        'analytics_pie_types': "Pie Chart of Question Types",
        'analytics_recent_log': "Recent Activity Log",
        'analytics_upload_csv': "Upload a CSV file for visualization",
        'analytics_no_data': "No chat data to display.",
        'analytics_no_conversations': "No conversation data found.",
        'analytics_no_keywords': "No crop keywords found in chats.",
        'analytics_no_disease': "No disease keywords found in chats.",
        'analytics_no_types': "No question type data found.",
        'analytics_info_upload': "If you want to visualize other CSV/statistics, upload them below:",
    },
}

# --- Helper for translation ---
def t(key, lang):
    return TRANSLATIONS.get(lang, TRANSLATIONS['en']).get(key, key)

# --- Session state for language and navigation ---
def init_session():
    if 'lang' not in st.session_state:
        st.session_state['lang'] = 'en'
    if 'page' not in st.session_state:
        st.session_state['page'] = 'home'
    if 'diagnosis_result' not in st.session_state:
        st.session_state['diagnosis_result'] = None
    if 'severity' not in st.session_state:
        st.session_state['severity'] = None
    if 'correction' not in st.session_state:
        st.session_state['correction'] = None

# --- User/Admin Login System ---
ADMIN_USERNAME = 'surya001'
ADMIN_PASSWORD = '1234'

def login_page():
    # Show KrishiSakhi app title at the top
    lang = st.session_state.get('lang', 'en')
    st.markdown(f"<h1 style='text-align:center; color:#388e3c;'>" + t('app_title', lang) + "</h1>", unsafe_allow_html=True)
    st.title('Login')
    username = st.text_input('Username', key='login_username')
    password = st.text_input('Password', type='password', key='login_password')
    if st.button('Login'):
        if username == ADMIN_USERNAME and password == ADMIN_PASSWORD:
            st.session_state['logged_in'] = True
            st.session_state['role'] = 'admin'
            st.session_state['username'] = username
            st.rerun()
        elif username and password and not (username == ADMIN_USERNAME):
            st.session_state['logged_in'] = True
            st.session_state['role'] = 'user'
            st.session_state['username'] = username
            st.rerun()
        else:
            st.error('Invalid username or password.')
    st.info('Admin: surya001 / 1234')
    st.info('Any other username/password is a normal user.')

# --- Modified Sidebar Navigation ---
def sidebar_navigation():
    lang = st.session_state['lang']
    st.sidebar.title(t('app_title', lang))
    # Language selection
    lang_display = {
        'en': 'English',
        'te': '‡∞§‡±Ü‡∞≤‡±Å‡∞ó‡±Å',
        'hi': '‡§π‡§ø‡§®‡•ç‡§¶‡•Ä',
        'ta': '‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç',
        'kn': '‡≤ï‡≤®‡≥ç‡≤®‡≤°',
        'ml': '‡¥Æ‡¥≤‡¥Ø‡¥æ‡¥≥‡¥Ç'
    }
    lang_keys = list(lang_display.keys())
    lang_names = [lang_display[k] for k in lang_keys]
    selected_lang = st.sidebar.selectbox(t('select_language', lang), lang_names, index=lang_keys.index(lang))
    st.session_state['lang'] = {v: k for k, v in lang_display.items()}[selected_lang]
    # --- Geolocation display and override ---
    st.sidebar.markdown('---')
    # Try browser geolocation first
    geo = streamlit_geolocation.geolocation()
    if geo and geo.get('latitude') and geo.get('longitude'):
        loc = {
            'latitude': geo['latitude'],
            'longitude': geo['longitude'],
            'city': '',
            'region': '',
            'country': ''
        }
        st.sidebar.write('**Detected Location (Browser):**')
        st.sidebar.write(f"Lat: {geo['latitude']}, Lon: {geo['longitude']}")
    else:
        loc = get_geolocation()
        st.sidebar.write('**Detected Location (IP):**')
        st.sidebar.write(f"{loc.get('city', '')}, {loc.get('region', '')}, {loc.get('country', '')}")
    if st.sidebar.checkbox('Override location'):
        city = st.sidebar.text_input('City', value=loc.get('city', ''))
        region = st.sidebar.text_input('Region/State', value=loc.get('region', ''))
        country = st.sidebar.text_input('Country', value=loc.get('country', ''))
        lat = st.sidebar.number_input('Latitude', value=loc.get('latitude', 0.0), format='%f')
        lon = st.sidebar.number_input('Longitude', value=loc.get('longitude', 0.0), format='%f')
        if st.sidebar.button('Set Location'):
            st.session_state['user_location'] = {
                'latitude': lat,
                'longitude': lon,
                'city': city,
                'region': region,
                'country': country
            }
            import json
            log_user_input('sidebar', 'location_override', json.dumps({'latitude': lat, 'longitude': lon, 'city': city, 'region': region, 'country': country}))
            st.sidebar.success('Location updated!')
    # Page selection (add Analytics Dashboard)
    page_labels = [
        t('home', lang),
        t('recommendations', lang),
        t('diagnosis', lang),
        t('growth_diary', lang),
        t('knowledge_sharing', lang),
        t('soil_health', lang),
        t('heatmaps', lang),
        t('khet_market', lang),
        t('analytics_dashboard', lang)
    ]
    if st.session_state.get('role') == 'admin':
        page_labels.append('Get Corpus Data')
    page = st.sidebar.radio('Go to', page_labels)
    page_map = {
        t('home', lang): 'home',
        t('recommendations', lang): 'recommendations',
        t('diagnosis', lang): 'diagnosis',
        t('growth_diary', lang): 'growth-diary',
        t('knowledge_sharing', lang): 'knowledge-sharing',
        t('soil_health', lang): 'soil-health',
        t('heatmaps', lang): 'heatmaps',
        t('khet_market', lang): 'khet-market',
        t('analytics_dashboard', lang): 'analytics-dashboard',
        'Get Corpus Data': 'get-corpus-data'
    }
    st.session_state['page'] = page_map[page]
    st.sidebar.markdown('---')
    st.sidebar.write(f"Logged in as: {st.session_state.get('username','')} ({st.session_state.get('role','')})")
    if st.sidebar.button('Logout'):
        for k in list(st.session_state.keys()):
            del st.session_state[k]
        st.rerun()

# --- AgriBot Chat Home Page (Gemini) ---
def agri_chat_page():
    import uuid
    import google.generativeai as genai
    from dotenv import load_dotenv
    load_dotenv()
    lang = st.session_state['lang']
    genai.configure(api_key=os.environ.get("AIzaSyDdmBu49KXJ7r0zEzcHekS0O34JoWylv1M"))
    generation_config = {
        "temperature": 0.7,
        "top_p": 0.95,
        "top_k": 40,
        "max_output_tokens": 8192,
        "response_mime_type": "text/plain",
    }
    model = genai.GenerativeModel(
        model_name="gemini-2.0-flash-exp",
        generation_config=generation_config,
        system_instruction=SYSEM_INSTRUCTION,
    )
    CONV_FILE = "conversations.json"
    def load_conversations():
        if not os.path.exists(CONV_FILE):
            with open(CONV_FILE, 'w') as f:
                json.dump({}, f)
        with open(CONV_FILE, 'r') as f:
            return json.load(f)
    def save_conversations(conversations):
        with open(CONV_FILE, 'w') as f:
            json.dump(conversations, f, indent=4)
    def get_user_id():
        if 'user_id' not in st.session_state:
            st.session_state['user_id'] = str(uuid.uuid4())
        return st.session_state['user_id']
    st.title(t('agribot_title', lang))
    st.markdown(
        f'<div style="background-color:#e0f7fa;padding:10px;border-radius:8px;margin-bottom:10px;">'
        f'<b>{t("agribot", lang)}:</b> {t("agribot_greeting", lang)}'
        '</div>', unsafe_allow_html=True)
    user_id = get_user_id()
    conversations = load_conversations()
    user_history = conversations.get(user_id, [])
    # Chat input (single field + attachment, with preview)
    col1, col2 = st.columns([4,2])
    with col1:
        user_message = st.text_input(t("agribot_input_placeholder", lang), key="user_message")
    with col2:
        image_file = st.file_uploader(t("agribot_attach_image", lang), type=['jpg', 'jpeg', 'png'], key="image_file")
        if image_file:
            st.image(image_file, width=120, caption="Preview")
    send_clicked = st.button(t("send", lang))
    if send_clicked and user_message:
        # Save image if uploaded
        image_path = None
        if image_file:
            uploads_dir = "uploads"
            os.makedirs(uploads_dir, exist_ok=True)
            image_path = os.path.join(uploads_dir, image_file.name)
            with open(image_path, "wb") as f:
                f.write(image_file.read())
        # Prepare Gemini input
        files = []
        new_image = None
        if image_path and os.path.exists(image_path):
            new_image = genai.upload_file(image_path)
            files.append(new_image)
        # Only keep allowed keys: 'role' and 'parts'
        filtered_history = [
            {k: v for k, v in entry.items() if k in ("role", "parts")}
            for entry in user_history
        ]
        chat_session = model.start_chat(history=filtered_history)
        response = chat_session.send_message(content=[user_message, new_image] if new_image else user_message)
        bot_reply = response.text
        # Update history
        user_history.append({"role": "user", "parts": [user_message], "timestamp": datetime.utcnow().isoformat()})
        user_history.append({"role": "model", "parts": [bot_reply], "timestamp": datetime.utcnow().isoformat()})
        conversations[user_id] = user_history
        save_conversations(conversations)
        st.experimental_rerun()
    # Show chat history (conversational bubbles)
    st.markdown("---")
    for msg in user_history:
        if msg['role'] == 'user':
            st.markdown(
                f'<div style="background-color:#fffde7;padding:8px 12px;border-radius:8px;margin-bottom:6px;text-align:right;"><b>{t("you", lang)}:</b> {msg["parts"][0]}</div>',
                unsafe_allow_html=True)
        else:
            st.markdown(
                f'<div style="background-color:#e0f7fa;padding:8px 12px;border-radius:8px;margin-bottom:6px;text-align:left;"><b>{t("agribot", lang)}:</b> {msg["parts"][0]}</div>',
                unsafe_allow_html=True)

# --- Home page ---
def home_page():
    import os
    import json
    import google.generativeai as genai
    from google.ai.generativelanguage_v1beta.types import content
    from werkzeug.utils import secure_filename
    import streamlit as st

    # Display main app title first
    st.markdown('<h1 style="text-align:center; color:#388e3c;">üåæ KrishiSakhi: AI-Driven Farming Assistant üåæ</h1>', unsafe_allow_html=True)

    # Configure Gemini API
    api_key = "AIzaSyDdmBu49KXJ7r0zEzcHekS0O34JoWylv1M"
    genai.configure(api_key=api_key)

    # Constants
    UPLOAD_FOLDER = "uploads"
    DATABASE = "conversations.json"
    os.makedirs(UPLOAD_FOLDER, exist_ok=True)

    # System instruction for the model
    SYSTEM_INSTRUCTION = """You are AgriBot, a highly intelligent and specialized AI assistant designed to help farmers and agricultural professionals optimize their work. Your main responsibilities include:

Plant Disease Diagnosis üåøüî¨

Analyze uploaded photos of plants.
Detect diseases, nutrient deficiencies, or pest infestations.
Provide precise diagnoses with explanations.
Suggest treatment solutions, including organic and chemical remedies.
General Agricultural Assistance üöúüåæ

Answer farming-related questions (soil health, irrigation, fertilization, pest control).
Provide best practices for different crops and climates.
Guide users on sustainable farming techniques and respond by the same language writen by the user.
Smart and Professional Communication üó£Ô∏èü§ñ

Be clear, concise, and professional in responses.
Use easy-to-understand language for farmers of all expertise levels.
Provide scientific insights in a user-friendly way.
Example Interaction:

üë®‚Äçüåæ User: "My tomato leaves have yellow spots. What should I do?"
ü§ñ AgriBot:
"Based on your photo, your tomato plant may have early blight (Alternaria solani), a common fungal disease. I recommend:
‚úÖ Removing infected leaves.
‚úÖ Applying a copper-based fungicide.
‚úÖ Ensuring good air circulation to prevent moisture buildup.
Let me know if you need organic alternatives! """

    # Initialize the model
    generation_config = {
        "temperature": 0.7,
        "top_p": 0.95,
        "top_k": 40,
        "max_output_tokens": 8192,
        "response_mime_type": "text/plain",
    }

    model = genai.GenerativeModel(
        model_name="gemini-2.0-flash-exp",
        generation_config=generation_config,
        system_instruction=SYSTEM_INSTRUCTION,
    )

    def load_conversations() -> dict:
        if not os.path.exists(DATABASE):
            with open(DATABASE, "w") as f:
                json.dump({}, f)
        with open(DATABASE, "r") as f:
            return json.load(f)

    def save_conversations(conversations):
        with open(DATABASE, "w") as f:
            json.dump(conversations, f, indent=4)

    def save_uploaded_file(uploaded_file):
        filename = secure_filename(uploaded_file.name)
        filepath = os.path.join(UPLOAD_FOLDER, filename)
        with open(filepath, "wb") as f:
            f.write(uploaded_file.getbuffer())
        return filepath, filename

    st.title("AgriBot - AI Assistant for Farmers")

    # User ID input (for session identification)
    user_id = st.text_input("Enter your user ID:", value="default_user")

    # Load conversation history
    conversations = load_conversations()
    user_history = conversations.get(user_id, [])

    # Image upload
    uploaded_file = st.file_uploader("Upload an image of your plant (optional)", type=["png", "jpg", "jpeg"])

    image_path = None
    if uploaded_file is not None:
        filepath, filename = save_uploaded_file(uploaded_file)
        image_path = filepath
        st.image(uploaded_file, caption="Uploaded Image", use_column_width=True)

    # User message input
    user_message = st.text_area("Enter your message to AgriBot:")

    if st.button("Send"):
        if not user_message:
            st.error("Message cannot be empty")
        else:
            # Upload image to Gemini if provided
            files = []
            new_image = None
            if image_path and os.path.exists(image_path):
                new_image = genai.upload_file(image_path)
                files.append(new_image)

            # Start chat session with history (filter out non-standard fields)
            filtered_history = [
                {k: v for k, v in entry.items() if k in ("role", "parts")}
                for entry in user_history
            ]
            chat_session = model.start_chat(history=filtered_history)
            response = chat_session.send_message(content=[user_message, new_image] if new_image else user_message)
            bot_reply = response.text

            # Save conversation
            user_history.append({"role": "user", "parts": [user_message], "timestamp": datetime.utcnow().isoformat()})
            user_history.append({"role": "model", "parts": [bot_reply], "timestamp": datetime.utcnow().isoformat()})
            conversations[user_id] = user_history
            save_conversations(conversations)

            # Display bot reply
            st.markdown(f"**AgriBot:** {bot_reply}")

    # Show conversation history only when button is clicked
    if st.button("Show Conversation History"):
        st.subheader("Conversation History")
        for entry in user_history:
            role = entry.get("role")
            parts = entry.get("parts", [])
            if role == "user":
                for part in parts:
                    st.markdown(f"**You:** {part}")
            elif role == "model":
                for part in parts:
                    st.markdown(f"**AgriBot:** {part}")

# --- Recommendations page ---
def recommendations_page(farmer_advisor, market_researcher, weather_module, agri_expert, memory):
    import pandas as pd
    import numpy as np
    lang = st.session_state['lang']
    st.title(t('recommendations', lang))
    st.header(t('enter_farm_data', lang))
    farm_id = st.text_input(t('farm_id', lang), value="1")
    # New: N, P, K input fields
    n = st.number_input('Nitrogen (N)', min_value=0.0, max_value=100.0, value=10.0, step=0.1)
    p = st.number_input('Phosphorus (P)', min_value=0.0, max_value=100.0, value=10.0, step=0.1)
    k = st.number_input('Potassium (K)', min_value=0.0, max_value=100.0, value=10.0, step=0.1)
    soil_ph = st.number_input(t('soil_ph', lang), min_value=0.0, max_value=14.0, value=6.5, step=0.1)
    soil_moisture = st.number_input(t('soil_moisture', lang), min_value=0.0, max_value=100.0, value=50.0, step=0.1)
    temperature_c = st.number_input(t('temperature', lang), min_value=-50.0, max_value=60.0, value=25.0, step=0.1)
    rainfall_mm = st.number_input(t('rainfall', lang), min_value=0.0, max_value=1000.0, value=100.0, step=0.1)
    crop_options = [
        ("Wheat", "üåæ Wheat: Cool-season cereal, staple food, high in protein."),
        ("Rice", "üçö Rice: Warm-season cereal, grown in flooded fields, staple in Asia."),
        ("Maize", "üåΩ Maize (Corn): Versatile cereal, used for food, feed, and industry."),
        ("Soybean", "ü´ò Soybean: Protein-rich legume, improves soil fertility."),
        ("Cotton", "üßµ Cotton: Fiber crop, requires warm climate and irrigation."),
        ("Sugarcane", "üç¨ Sugarcane: Tropical grass, source of sugar and ethanol."),
        ("Groundnut", "ü•ú Groundnut (Peanut): Oilseed legume, drought-tolerant."),
        ("Potato", "ü•î Potato: Cool-season tuber, rich in carbohydrates."),
        ("Tomato", "üçÖ Tomato: Popular vegetable, needs warm weather, prone to diseases."),
        ("Onion", "üßÖ Onion: Bulb vegetable, grows in many climates."),
        ("Chickpea", "ÔøΩÔøΩ Chickpea: Protein-rich pulse, good for dry areas."),
        ("Mustard", "üåª Mustard: Oilseed, cool-season crop, used for oil and greens."),
        ("Sorghum", "üåæ Sorghum: Drought-tolerant cereal, used for food and fodder."),
        ("Banana", "üçå Banana: Tropical fruit, needs rich soil and moisture."),
        ("Grapes", "üçá Grapes: Fruit crop, grown in temperate and tropical regions."),
        ("Mango", "ü•≠ Mango: King of fruits, needs hot, dry weather for ripening."),
        ("Pigeonpea", "üåø Pigeonpea: Drought-resistant pulse, improves soil health."),
        ("Sunflower", "üåª Sunflower: Oilseed, grows well in sunny, dry areas."),
        ("Pea", "üå± Pea: Cool-season legume, rich in protein.")
    ]
    crop_names = [c[0] for c in crop_options]
    crop = st.selectbox(t('select_crop', lang), crop_names)
    crop_detail = dict(crop_options)[crop]
    st.caption(crop_detail)
    fertilizer_usage_kg = st.number_input(t('fertilizer_usage', lang), min_value=0.0, max_value=500.0, value=100.0, step=0.1)
    pesticide_usage_kg = st.number_input(t('pesticide_usage', lang), min_value=0.0, max_value=100.0, value=10.0, step=0.1)
    crop_yield_ton = st.number_input(t('crop_yield', lang), min_value=0.0, max_value=100.0, value=5.0, step=0.1)
    sustainability_score = st.number_input(t('sustainability_score', lang), min_value=0.0, max_value=100.0, value=50.0, step=0.1)
    if st.button(t('get_recommendations', lang)):
        soil_data = {
            "N": n,
            "P": p,
            "K": k,
            "ph": soil_ph,
            "moisture": soil_moisture,
            "temperature": temperature_c,
            "rainfall": rainfall_mm
        }
        user_input = {
            "farm_id": farm_id,
            "N": n,
            "P": p,
            "K": k,
            "soil_ph": soil_ph,
            "soil_moisture": soil_moisture,
            "temperature_c": temperature_c,
            "rainfall_mm": rainfall_mm,
            "crop_type": crop,
            "fertilizer_usage_kg": fertilizer_usage_kg,
            "pesticide_usage_kg": pesticide_usage_kg,
            "crop_yield_ton": crop_yield_ton,
            "sustainability_score": sustainability_score,
            "crop": crop
        }
        import json
        log_user_input('recommendations', 'form', json.dumps(user_input))
        memory.log_interaction("User", str(user_input), "Started analysis")
        # Prepare input for FarmerAdvisor model (only features present in training data)
        model_input = {
            "Farm_ID": int(farm_id),
            "Soil_pH": soil_ph,
            "Soil_Moisture": soil_moisture,
            "Temperature_C": temperature_c,
            "Rainfall_mm": rainfall_mm,
            "Crop_Type": crop,
            "Fertilizer_Usage_kg": fertilizer_usage_kg,
            "Pesticide_Usage_kg": pesticide_usage_kg,
            "Crop_Yield_ton": crop_yield_ton,
            "Sustainability_Score": sustainability_score
        }
        loc = get_geolocation()
        # --- Real Crop Prediction using Crop_recommendation.csv ---
        try:
            df = pd.read_csv('Crop_recommendation.csv')
            # Compute distance to each row
            features = ['N','P','K','temperature','humidity','ph','rainfall']
            input_vec = np.array([n, p, k, temperature_c, soil_moisture, soil_ph, rainfall_mm])
            df_features = df[features].values
            dists = np.linalg.norm(df_features - input_vec, axis=1)
            best_idx = np.argmin(dists)
            best_crop = df.iloc[best_idx]['label']
        except Exception as e:
            best_crop = f"[Error: {e}]"
        # --- Fertilizer Recommendation using fertilizer.csv ---
        fert_reco = None
        try:
            fert_df = pd.read_csv('fertilizer.csv')
            fert_row = fert_df[fert_df['Crop'].str.lower() == str(best_crop).lower()]
            if not fert_row.empty:
                fert_row = fert_row.iloc[0]
                fert_reco = {
                    'N': fert_row['N'],
                    'P': fert_row['P'],
                    'K': fert_row['K'],
                    'pH': fert_row['pH'],
                    'soil_moisture': fert_row['soil_moisture']
                }
        except Exception as e:
            fert_reco = f"[Error: {e}]"
        land_advice = farmer_advisor.get_recommendations(model_input)
        market_advice = market_researcher.analyze({"crop": crop})
        weather_report = weather_module.get_real_time_weather()
        sustainability_advice = agri_expert.provide_guidance({"crop": crop, "soil": soil_data})
        final_recommendations = {
            'Soil Advice': land_advice,
            'Market Trends': market_advice,
            'Weather Forecast': weather_report,
            'Sustainability Tips': sustainability_advice,
            'Best Crop Prediction': best_crop,
            'Fertilizer Recommendation': fert_reco
        }
        memory.log_interaction("System", str(user_input), str(final_recommendations))
        st.subheader(t('soil_recommendations', lang))
        st.info(f"Best Crop to Grow (Data-Driven Prediction): {best_crop}")
        if fert_reco:
            st.subheader('Recommended Fertilizer Parameters')
            if isinstance(fert_reco, dict):
                st.write(f"N: {fert_reco['N']}, P: {fert_reco['P']}, K: {fert_reco['K']}, pH: {fert_reco['pH']}, Soil Moisture: {fert_reco['soil_moisture']}")
            else:
                st.write(fert_reco)
        if isinstance(land_advice, dict) and "error" in land_advice:
            st.error(land_advice["error"])
        else:
            if isinstance(land_advice, dict):
                st.markdown("**Prediction:** " + str(land_advice.get("prediction", "")))
                st.markdown("**Confidence:** " + str(land_advice.get("confidence", "")) + "%")
                st.markdown("**Input Used:**")
                input_used = land_advice.get("input_used", {})
                for key, value in input_used.items():
                    st.markdown(f"- {key}: {value}")
            else:
                st.write(land_advice)
        st.subheader(t('market_trends', lang))
        st.write(market_advice)
        st.subheader(t('weather_forecast', lang))
        st.write(weather_report)
        st.subheader(t('sustainable_practices', lang))
        for tip in sustainability_advice.split("\n"):
            st.write(f"- {tip}")

# --- Voice input using streamlit-webrtc and SpeechRecognition ---
def voice_input_component(lang):
    import tempfile
    from streamlit_webrtc import webrtc_streamer, AudioProcessorBase
    import av
    try:
        from vosk import Model, KaldiRecognizer
        vosk_available = True
    except ImportError:
        vosk_available = False
    import json
    import os

    class AudioProcessor(AudioProcessorBase):
        def __init__(self):
            self.frames = []
        def recv(self, frame):
            self.frames.append(frame.to_ndarray())
            return frame

    ctx = webrtc_streamer(key="voice", audio_receiver_size=1024, audio_processor_factory=AudioProcessor)
    text = ""
    if not vosk_available:
        st.error("Vosk is not installed. Please install vosk to use voice input.")
        return text
    if ctx.audio_receiver:
        audio_frames = ctx.audio_receiver.get_frames(timeout=1)
        if audio_frames:
            # Save audio to temp file
            with tempfile.NamedTemporaryFile(suffix=".wav", delete=False) as f:
                for audio_frame in audio_frames:
                    f.write(audio_frame.to_ndarray().tobytes())
                audio_path = f.name
            # Recognize speech using Vosk
            model_path = st.text_input("Vosk Model Path", value="vosk-model-small-en-us-0.15")
            if not os.path.exists(model_path):
                st.error(f"[Error: Vosk model not found at {model_path}]")
                text = ""
            else:
                try:
                    model = Model(model_path)
                    rec = KaldiRecognizer(model, 16000)
                    with open(audio_path, "rb") as audio_file:
                        while True:
                            data = audio_file.read(4000)
                            if len(data) == 0:
                                break
                            if rec.AcceptWaveform(data):
                                pass
                    result = rec.FinalResult()
                    try:
                        result_json = json.loads(result)
                        text = result_json.get("text", "")
                    except Exception as e:
                        text = f"[Error: {e} in parsing Vosk result]"
                except Exception as e:
                    st.error(f"[Error: {e} in Vosk recognition]")
                    text = ""
            os.remove(audio_path)
    return text

# --- Diagnosis page (image, voice, text input) ---
def diagnosis_page():
    lang = st.session_state['lang']
    st.title(t('diagnosis', lang))
    st.header(t('input_options', lang))
    input_type = st.radio("Select Input Type", [t('image_input', lang), t('voice_input', lang), t('text_input', lang)])
    diagnosis_result = None
    classifier = ImageClassifier()
    if input_type == t('image_input', lang):
        uploaded_file = st.file_uploader(t('image_input', lang), type=['jpg', 'jpeg', 'png'])
        if uploaded_file is not None:
            image = Image.open(uploaded_file).convert('RGB')
            st.image(image, caption="Uploaded Image", use_container_width=True)
            import json
            log_user_input('diagnosis', 'image', json.dumps({'filename': uploaded_file.name}))
            with st.spinner("Classifying image..."):
                disease, confidence, cure = classifier.predict(image)
            st.success(f"Predicted Disease: {disease} (Confidence: {confidence*100:.2f}%)")
            st.info(f"Recommended Cure/Treatment: {cure}")
            # --- Show severity estimation automatically ---
            if confidence > 0.75:
                severity = random.choice(['Low', 'Medium', 'High'])
            else:
                severity = 'Low'
            percent = int(confidence * 100)
            st.info(f"Estimated Severity: {severity} ({percent}%)")
            st.session_state['diagnosis_result'] = {'disease': disease, 'confidence': confidence, 'cure': cure, 'severity': severity, 'percent': percent}
            # --- Farmer validation/correction workflow ---
            is_correct = st.radio("Is the above information correct?", ["Yes", "No"])
            if is_correct == "No":
                correction = st.text_input("Please provide the correct diagnosis:")
                if st.button("Submit Feedback"):
                    st.session_state['correction'] = correction
                    st.success("Thank you for your feedback!")
            # If 'Yes', do not show anything further
    elif input_type == t('voice_input', lang):
        st.write(t('voice_input', lang))
        voice_mode = st.radio("Choose voice input method:", ["Upload Audio File", "Record Live Audio"])
        text = ""
        audio_bytes = None
        audio_file_path = None
        if voice_mode == "Upload Audio File":
            uploaded_audio = st.file_uploader("Upload Audio File", type=["wav", "mp3", "ogg"])
            if uploaded_audio is not None:
                audio_bytes = uploaded_audio.read()
                import json
                log_user_input('diagnosis', 'voice_upload', json.dumps({'filename': uploaded_audio.name}))
        elif voice_mode == "Record Live Audio":
            try:
                from streamlit_audiorecorder import audiorecorder
                audio_bytes = audiorecorder("Click to record", "Recording...")
                if audio_bytes:
                    import json
                    log_user_input('diagnosis', 'voice_record', json.dumps({'length': len(audio_bytes)}))
            except ImportError:
                st.error("streamlit-audiorecorder is not installed. Please install it with 'pip install streamlit-audiorecorder'.")
        # --- Save and play audio after recording/upload ---
        if audio_bytes:
            import tempfile
            import os
            # Save to persistent location for playback
            audio_dir = os.path.join("uploads", "audio_diagnosis")
            os.makedirs(audio_dir, exist_ok=True)
            import uuid
            audio_filename = f"audio_{uuid.uuid4().hex}.wav"
            audio_file_path = os.path.join(audio_dir, audio_filename)
            with open(audio_file_path, 'wb') as f:
                f.write(audio_bytes)
            st.audio(audio_file_path, format='audio/wav')
            # Also save to temp for Vosk processing
            with tempfile.NamedTemporaryFile(delete=False, suffix=".wav") as tmp_audio:
                tmp_audio.write(audio_bytes)
                tmp_audio_path = tmp_audio.name
            # Speech-to-text with Vosk
            try:
                from vosk import Model, KaldiRecognizer
                import wave
                import json
                model_path = st.text_input("Vosk Model Path", value="vosk-model-small-en-us-0.15")
                if not os.path.exists(model_path):
                    st.error(f"[Error: Vosk model not found at {model_path}]")
                else:
                    wf = wave.open(tmp_audio_path, "rb")
                    model = Model(model_path)
                    rec = KaldiRecognizer(model, wf.getframerate())
                    while True:
                        data = wf.readframes(4000)
                        if len(data) == 0:
                            break
                        rec.AcceptWaveform(data)
                    result = rec.FinalResult()
                    result_json = json.loads(result)
                    text = result_json.get("text", "")
                    st.write(f"Recognized Text: {text}")
                    # Use NLP model to predict disease from text
                    nlp_models = NLPModels()
                    with st.spinner("Analyzing text for disease diagnosis..."):
                        disease = nlp_models.summarize(text)
                        confidence = 0.85  # Placeholder confidence
                    st.success(f"Predicted Disease: {disease} (Confidence: {confidence*100:.2f}%)")
                    # --- Show severity estimation automatically ---
                    if confidence > 0.75:
                        severity = random.choice(['Low', 'Medium', 'High'])
                    else:
                        severity = 'Low'
                    percent = int(confidence * 100)
                    st.info(f"Estimated Severity: {severity} ({percent}%)")
                    st.session_state['diagnosis_result'] = {'disease': disease, 'confidence': confidence, 'input_text': text, 'severity': severity, 'percent': percent, 'audio_file': audio_file_path}
                    # --- Farmer validation/correction workflow ---
                    is_correct = st.radio("Is the above information correct?", ["Yes", "No"])
                    if is_correct == "No":
                        correction = st.text_input("Please provide the correct diagnosis:")
                        if st.button("Submit Feedback"):
                            st.session_state['correction'] = correction
                            st.success("Thank you for your feedback!")
                    # If 'Yes', do not show anything further
            except Exception as e:
                st.error(f"Speech recognition error: {e}")
            finally:
                os.remove(tmp_audio_path)
    elif input_type == t('text_input', lang):
        text_query = st.text_area(t('text_input', lang))
        if st.button(t('submit', lang)):
            import json
            log_user_input('diagnosis', 'text', json.dumps({'text': text_query}))
            # Use NLP model to predict disease from text
            nlp_models = NLPModels()
            with st.spinner("Analyzing text for disease diagnosis..."):
                disease = nlp_models.summarize(text_query)
                confidence = 0.85  # Placeholder confidence
            st.success(f"Predicted Disease: {disease} (Confidence: {confidence*100:.2f}%)")
            # --- Show severity estimation automatically ---
            if confidence > 0.75:
                severity = random.choice(['Low', 'Medium', 'High'])
            else:
                severity = 'Low'
            percent = int(confidence * 100)
            st.info(f"Estimated Severity: {severity} ({percent}%)")
            st.session_state['diagnosis_result'] = {'disease': disease, 'confidence': confidence, 'input_text': text_query, 'severity': severity, 'percent': percent}
            # --- Farmer validation/correction workflow ---
            is_correct = st.radio("Is the above information correct?", ["Yes", "No"])
            if is_correct == "No":
                correction = st.text_input("Please provide the correct diagnosis:")
                if st.button("Submit Feedback"):
                    st.session_state['correction'] = correction
                    st.success("Thank you for your feedback!")
            # If 'Yes', do not show anything further

# --- Severity estimation page ---
def severity_page():
    lang = st.session_state['lang']
    st.title(t('severity', lang))
    diagnosis_result = st.session_state.get('diagnosis_result', None)
    if diagnosis_result:
        st.write(t('ai_diagnosis', lang) + f": {diagnosis_result['disease']} ({diagnosis_result['confidence']*100:.1f}%)")
        # Provide a stub severity estimation based on confidence or random
        confidence = diagnosis_result.get('confidence', 0)
        if confidence > 0.75:
            severity = random.choice(['Low', 'Medium', 'High'])
        else:
            severity = 'Low'
        percent = int(confidence * 100)
        st.info(f"Estimated Severity: {severity} ({percent}%)")
        st.session_state['severity'] = {'severity': severity, 'percent': percent}
        st.button(t('validation', lang), on_click=lambda: st.session_state.update({'page': 'validation'}))
    else:
        st.warning("No diagnosis result found.")

# --- Farmer validation/correction page ---
def validation_page():
    lang = st.session_state['lang']
    st.title(t('validation', lang))
    diagnosis_result = st.session_state.get('diagnosis_result', None)
    severity = st.session_state.get('severity', None)
    if diagnosis_result and severity:
        st.write(t('ai_diagnosis', lang) + f": {diagnosis_result['disease']} ({diagnosis_result['confidence']*100:.1f}%)")
        st.write(t('severity_result', lang) + f": {severity['severity']} ({severity['percent']}%)")
        is_correct = st.radio(t('validation_prompt', lang), ["Yes", "No"])
        if is_correct == "No":
            correction = st.text_input(t('correction_prompt', lang))
            if st.button(t('submit', lang)):
                st.session_state['correction'] = correction
                st.success(t('thank_you', lang))
        else:
            st.success(t('thank_you', lang))
    else:
        st.warning("No diagnosis/severity result found.")

def growth_diary_page():
    lang = st.session_state['lang']
    st.title(t('growth_diary', lang))
    diary_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'dataset_farming', 'diary_log.csv')
    # Load or create diary log
    if os.path.exists(diary_path):
        diary_df = pd.read_csv(diary_path)
    else:
        diary_df = pd.DataFrame(columns=['date','crop','notes','image_path','weather'])
    # Entry form
    st.subheader(t('add_entry', lang))
    entry_date = st.date_input('Date', date.today())
    crop = st.text_input(t('crop', lang))
    notes = st.text_area(t('notes', lang))
    image = st.file_uploader('Upload Image', type=['jpg','jpeg','png'])
    weather = st.text_input('Weather (optional)')
    if st.button(t('save_entry', lang)):
        image_path = ''
        if image:
            img_save_path = os.path.join(os.path.dirname(diary_path), f'diary_{entry_date}_{crop}_{image.name}')
            with open(img_save_path, 'wb') as f:
                f.write(image.read())
            image_path = img_save_path
        new_entry = {'date': entry_date.isoformat() if hasattr(entry_date, 'isoformat') else str(entry_date), 'crop': crop, 'notes': notes, 'image_path': image_path, 'weather': weather}
        import json
        log_user_input('growth_diary', 'entry', json.dumps(new_entry))
        diary_df = pd.concat([diary_df, pd.DataFrame([new_entry])], ignore_index=True)
        diary_df.to_csv(diary_path, index=False)
        st.success(t('entry_saved', lang))
    # Show diary log
    st.subheader(t('diary_log', lang))
    if not diary_df.empty:
        for idx, row in diary_df.iterrows():
            st.markdown(f"**Date:** {row['date']}  |  **{t('crop', lang)}:** {row['crop']}")
            st.markdown(f"**{t('notes', lang)}:** {row['notes']}")
            if row['image_path'] and os.path.exists(row['image_path']):
                st.image(row['image_path'], width=200)
            if row['weather']:
                st.markdown(f"**Weather:** {row['weather']}")
            st.markdown('---')

def knowledge_sharing_page():
    import pandas as pd
    lang = st.session_state['lang']
    forum_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'dataset_farming', 'forum_threads.csv')
    st.title(t('knowledge_sharing', lang))
    # Load or create forum threads
    if os.path.exists(forum_path):
        forum_df = pd.read_csv(forum_path)
    else:
        forum_df = pd.DataFrame(columns=['thread_id','title','content','timestamp','replies'])
    # New thread form
    st.subheader(t('start_discussion', lang))
    title = st.text_input('Title')
    content = st.text_area('Content')
    if st.button(t('post_thread', lang)):
        import time
        thread_id = int(time.time())
        now = datetime.now()
        new_thread = {'thread_id': thread_id, 'title': title, 'content': content, 'timestamp': now.isoformat(), 'replies': ''}
        import json
        log_user_input('knowledge_sharing', 'thread', json.dumps(new_thread))
        forum_df = pd.concat([forum_df, pd.DataFrame([new_thread])], ignore_index=True)
        forum_df.to_csv(forum_path, index=False)
        st.success(t('thread_posted', lang))
    # Show threads
    st.subheader(t('all_discussions', lang))
    if not forum_df.empty:
        for idx, row in forum_df.iterrows():
            st.markdown(f"**{row['title']}**  ")
            st.markdown(f"{row['content']}")
            st.caption(f"Posted at: {row['timestamp']}")
            # Replies
            if row['replies']:
                # Show text replies
                for reply in str(row['replies']).split('||AUDIO||'):
                    if reply.strip().endswith('.wav') and os.path.exists(reply.strip()):
                        st.audio(reply.strip(), format='audio/wav')
                    elif reply.strip():
                        st.markdown(f"**Reply:** {reply.strip()}")
            # Reply input
            reply = st.text_input(f'Reply to {row["thread_id"]}', key=f'reply_{row["thread_id"]}')
            audio_bytes = None
            audio_file_path = ''
            # Audio recording/upload
            col1, col2 = st.columns(2)
            with col1:
                try:
                    from streamlit_audiorecorder import audiorecorder
                    audio_bytes = audiorecorder("Record Audio Reply", "Recording...")
                except ImportError:
                    st.info("Install streamlit-audiorecorder for audio recording.")
            with col2:
                uploaded_audio = st.file_uploader("Or Upload Audio Reply", type=["wav", "mp3", "ogg"], key=f'upload_{row["thread_id"]}')
                if uploaded_audio:
                    audio_bytes = uploaded_audio.read()
            if st.button(t('reply', lang), key=f'btn_{row["thread_id"]}'):
                prev_replies = str(row['replies']) if row['replies'] else ''
                new_reply = ''
                if reply.strip():
                    new_reply += reply.strip()
                if audio_bytes:
                    # Save audio to file
                    import uuid
                    audio_dir = os.path.join(os.path.dirname(forum_path), 'audio_replies')
                    os.makedirs(audio_dir, exist_ok=True)
                    audio_filename = f"audio_{row['thread_id']}_{uuid.uuid4().hex}.wav"
                    audio_file_path = os.path.join(audio_dir, audio_filename)
                    with open(audio_file_path, 'wb') as f:
                        f.write(audio_bytes)
                    if new_reply:
                        new_reply += ' ||AUDIO|| ' + audio_file_path
                    else:
                        new_reply = audio_file_path
                # Append reply
                forum_df.at[idx, 'replies'] = (prev_replies + '\n' if prev_replies else '') + new_reply
                forum_df.to_csv(forum_path, index=False)
                st.success(t('reply_posted', lang))
            st.markdown('---')

def soil_health_page():
    import pandas as pd
    lang = st.session_state['lang']
    soil_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'dataset_farming', 'soil_tests.csv')
    st.title(t('soil_health', lang))
    # Load or create soil test log
    if os.path.exists(soil_path):
        soil_df = pd.read_csv(soil_path)
    else:
        soil_df = pd.DataFrame(columns=['date','pH','N','P','K','organic_matter','notes'])
    # Entry form
    st.subheader(t('add_soil_test', lang))
    soil_date = st.date_input('Date', date.today(), key='soil_date')
    ph = st.number_input('pH', min_value=0.0, max_value=14.0, value=6.5, step=0.1)
    n = st.number_input('Nitrogen (N)', min_value=0.0, max_value=100.0, value=0.0, step=0.1)
    p = st.number_input('Phosphorus (P)', min_value=0.0, max_value=100.0, value=0.0, step=0.1)
    k = st.number_input('Potassium (K)', min_value=0.0, max_value=100.0, value=0.0, step=0.1)
    om = st.number_input('Organic Matter (%)', min_value=0.0, max_value=100.0, value=0.0, step=0.1)
    notes = st.text_area(t('notes', lang), key='soil_notes')
    if st.button(t('save_soil_test', lang)):
        new_entry = {'date': soil_date.isoformat() if hasattr(soil_date, 'isoformat') else str(soil_date), 'pH': ph, 'N': n, 'P': p, 'K': k, 'organic_matter': om, 'notes': notes}
        import json
        log_user_input('soil_health', 'soil_test', json.dumps(new_entry))
        soil_df = pd.concat([soil_df, pd.DataFrame([new_entry])], ignore_index=True)
        soil_df.to_csv(soil_path, index=False)
        st.success(t('soil_test_saved', lang))
    # Show soil test log
    st.subheader(t('soil_test_log', lang))
    if not soil_df.empty:
        st.dataframe(soil_df)

def heatmaps_page():
    import pandas as pd
    import folium
    from streamlit_folium import st_folium
    lang = st.session_state['lang']
    st.title(t('heatmaps', lang))
    st.markdown(t('outbreak_map', lang))
    st.markdown("This feature shows real-time crop health status based on geo-tagged reports.")
    st.markdown("Below is a simulated heatmap view:")
    # Simulated outbreak locations
    sample_points = [
        (17.385044, 78.486671),  # Hyderabad
        (28.613939, 77.209023),  # Delhi
        (19.076090, 72.877426),  # Mumbai
        (13.082680, 80.270718),  # Chennai
        (23.022505, 72.571362)   # Ahmedabad
    ]
    # Get user geolocation if available
    loc = st.session_state.get('user_location', get_geolocation())
    center_lat = loc.get('latitude', 20.5937)
    center_lon = loc.get('longitude', 78.9629)
    # Initialize the Folium map
    m = folium.Map(location=[center_lat, center_lon], zoom_start=5)
    # Add circle markers
    for lat, lon in sample_points:
        folium.CircleMarker(
            location=[lat, lon],
            radius=10,
            color="red",
            fill=True,
            fill_opacity=0.6,
            popup="Reported Disease Outbreak"
        ).add_to(m)
    # Display the map in Streamlit
    st_folium(m, width=700, height=500)
    # Suggest suitable crops for the user's location
    st.markdown('---')
    st.subheader("üå± Suitable Crops for Your Location")
    # Simple logic: suggest crops based on region/city (can be improved with real data)
    city = loc.get('city', '').lower()
    region = loc.get('region', '').lower()
    crop_suggestions = {
        'hyderabad': ['Rice', 'Maize', 'Cotton'],
        'delhi': ['Wheat', 'Mustard', 'Barley'],
        'mumbai': ['Rice', 'Sugarcane', 'Vegetables'],
        'chennai': ['Rice', 'Millets', 'Groundnut'],
        'ahmedabad': ['Cotton', 'Groundnut', 'Wheat']
    }
    found = False
    for key, crops in crop_suggestions.items():
        if key in city or key in region:
            st.write(f"**{key.title()}**: {', '.join(crops)}")
            found = True
    if not found:
        st.write("General Suggestions: Rice, Wheat, Maize, Pulses")

def khet_market_page():
    lang = st.session_state['lang']
    if 'market_users' not in st.session_state:
        st.session_state['market_users'] = []
    if 'market_logged_in_user' not in st.session_state:
        st.session_state['market_logged_in_user'] = None
    if 'market_cart' not in st.session_state:
        st.session_state['market_cart'] = []
    if 'market_orders' not in st.session_state:
        st.session_state['market_orders'] = []
    if 'market_listings' not in st.session_state:
        st.session_state['market_listings'] = []
    st.title(t('khet_market', lang))
    tab_names = [
        t('market_home', lang), t('market_login', lang), t('market_register', lang), t('market_buyorsell', lang), t('market_buy', lang), t('market_checkout', lang), t('market_payment', lang), t('market_orders', lang), t('market_sell', lang), t('market_selling_item', lang)
    ]
    tab_objs = st.tabs(tab_names)
    with tab_objs[0]:
        st.header(t('market_home', lang))
        if st.session_state['market_logged_in_user']:
            st.success(f"Welcome, {st.session_state['market_logged_in_user']['fullname']}!")
        st.markdown(t('khet_market', lang) + ' - ' + t('market_home', lang))
        st.markdown('''Khet Market is a web-app through which farmers can sell crops to and buy equipment directly from other merchants without any third-party mediation. To avoid price inflation and maintain regularized selling, the app validates any purchase through the use of MSP for pricing and the buyer must adhere to it. The app also incorporates image integration for crops so the buyer can decide whether to proceed with the transaction. The app also incorporates payment authentication which helps both parties avoid extra middleman costs and helps in creating a completely self‚Äìindependent virtual market space to empower both the buyer and seller.''')
    with tab_objs[1]:
        st.header(t('market_login', lang))
        login_username = st.text_input(t('login_username', lang), key='login_username')
        login_password = st.text_input(t('login_password', lang), type='password', key='login_password')
        if st.button(t('login_btn', lang), key='login_btn'):
            import json
            log_user_input('khet_market', 'login', json.dumps({'username': login_username}))
            user = next((u for u in st.session_state['market_users'] if u['username'] == login_username and u['password'] == login_password), None)
            if user:
                st.session_state['market_logged_in_user'] = user
                st.success(f"Login successful! Welcome, {user['fullname']}.")
            else:
                st.error("Invalid username or password.")
        if st.session_state['market_logged_in_user']:
            st.info(f"Logged in as: {st.session_state['market_logged_in_user']['fullname']} ({st.session_state['market_logged_in_user']['username']})")
    with tab_objs[2]:
        st.header(t('market_register', lang))
        reg_fullname = st.text_input(t('register_fullname', lang), key='register_fullname')
        reg_email = st.text_input(t('register_email', lang), key='register_email')
        reg_phone = st.text_input(t('register_phone', lang), key='register_phone')
        reg_username = st.text_input(t('register_username', lang), key='register_username')
        reg_password = st.text_input(t('register_password', lang), type='password', key='register_password')
        reg_confirmpw = st.text_input(t('register_confirmpw', lang), type='password', key='register_confirmpw')
        if st.button(t('register_btn', lang), key='register_btn'):
            import json
            log_user_input('khet_market', 'register', json.dumps({'fullname': reg_fullname, 'email': reg_email, 'phone': reg_phone, 'username': reg_username}))
            if not reg_fullname or not reg_username or not reg_password or not reg_confirmpw:
                st.error("Please fill all required fields.")
            elif reg_password != reg_confirmpw:
                st.error("Passwords do not match.")
            elif any(u['username'] == reg_username for u in st.session_state['market_users']):
                st.error("Username already exists.")
            else:
                st.session_state['market_users'].append({
                    'fullname': reg_fullname,
                    'email': reg_email,
                    'phone': reg_phone,
                    'username': reg_username,
                    'password': reg_password
                })
                st.success("Registration successful! You can now log in.")
    with tab_objs[3]:  # BuyOrSell
        st.header(t('market_buyorsell', lang))
        if not st.session_state['market_logged_in_user']:
            st.warning('Please log in to continue.')
        else:
            col1, col2 = st.columns(2)
            with col1:
                if st.button(t('buyorsell_buy', lang), key='buyorsell_buy'):
                    st.query_params["tab"] = tab_names[4]
            with col2:
                if st.button(t('buyorsell_sell', lang), key='buyorsell_sell'):
                    st.query_params["tab"] = tab_names[8]
    with tab_objs[4]:  # Buy
        st.header(t('market_buy', lang))
        if not st.session_state['market_logged_in_user']:
            st.warning('Please log in to buy products.')
        else:
            products = [
                {'name': 'Wheat Seeds', 'price': 100},
                {'name': 'Fertilizer', 'price': 250},
                {'name': 'Tractor Rental', 'price': 5000},
                {'name': 'Pesticide', 'price': 150},
                {'name': 'Rice Seeds', 'price': 120},
            ]
            for i, prod in enumerate(products):
                col1, col2 = st.columns([3,1])
                with col1:
                    st.write(f"{prod['name']} - ‚Çπ{prod['price']}")
                with col2:
                    if st.button(f"Add to Cart {i}"):
                        st.session_state['market_cart'].append(prod)
                        st.success(f"Added {prod['name']} to cart.")
            st.write('---')
            st.write(f"Cart: {len(st.session_state['market_cart'])} items")
    with tab_objs[5]:  # Checkout
        st.header(t('market_checkout', lang))
        if not st.session_state['market_logged_in_user']:
            st.warning('Please log in to checkout.')
        elif not st.session_state['market_cart']:
            st.info('Your cart is empty.')
        else:
            total = sum(item['price'] for item in st.session_state['market_cart'])
            for i, item in enumerate(st.session_state['market_cart']):
                st.write(f"{item['name']} - ‚Çπ{item['price']}")
                if st.button(f"Remove {item['name']} {i}"):
                    st.session_state['market_cart'].pop(i)
                    st.experimental_rerun()
            st.write(f"**Total: ‚Çπ{total}**")
            if st.button('Proceed to Payment'):
                st.query_params["tab"] = tab_names[6]
    with tab_objs[6]:  # Payment
        st.header(t('market_payment', lang))
        if not st.session_state['market_logged_in_user']:
            st.warning('Please log in to pay.')
        elif not st.session_state['market_cart']:
            st.info('No items to pay for.')
        else:
            st.text_input(t('payment_card', lang), key='payment_card')
            st.text_input(t('payment_expiry', lang), key='payment_expiry')
            st.text_input(t('payment_cvv', lang), type='password', key='payment_cvv')
            if st.button(t('payment_btn', lang), key='payment_btn'):
                # Place order
                order = {
                    'user': st.session_state['market_logged_in_user']['username'],
                    'items': list(st.session_state['market_cart']),
                    'order_id': f"ORD{len(st.session_state['market_orders'])+1:04d}",
                    'total': sum(item['price'] for item in st.session_state['market_cart'])
                }
                st.session_state['market_orders'].append(order)
                st.session_state['market_cart'] = []
                st.success(f"Payment successful! Order ID: {order['order_id']}")
    with tab_objs[7]:  # Orders
        st.header(t('market_orders', lang))
        if not st.session_state['market_logged_in_user']:
            st.warning('Please log in to view orders.')
        else:
            user_orders = [o for o in st.session_state['market_orders'] if o['user'] == st.session_state['market_logged_in_user']['username']]
            if not user_orders:
                st.info('No orders yet.')
            else:
                for order in user_orders:
                    st.write(f"Order ID: {order['order_id']}")
                    for item in order['items']:
                        st.write(f"- {item['name']} - ‚Çπ{item['price']}")
                    st.write(f"Total: ‚Çπ{order['total']}")
                    st.write('---')
    with tab_objs[8]:  # Sell
        st.header(t('market_sell', lang))
        if not st.session_state['market_logged_in_user']:
            st.warning('Please log in to list crops for sale.')
        else:
            crop_name = st.text_input(t('sell_crop', lang), key='sell_crop')
            qty = st.number_input(t('sell_qty', lang), min_value=1, key='sell_qty')
            price = st.number_input(t('sell_price', lang), min_value=0.0, key='sell_price')
            crop_img = st.file_uploader(t('sell_img', lang), type=['jpg', 'jpeg', 'png'], key='sell_img')
            if st.button(t('sell_btn', lang), key='sell_btn'):
                import json
                log_user_input('khet_market', 'sell', json.dumps({'crop': crop_name, 'qty': qty, 'price': price, 'img': crop_img.name if crop_img else None}))
                st.session_state['market_listings'].append({
                    'user': st.session_state['market_logged_in_user']['username'],
                    'crop': crop_name,
                    'qty': qty,
                    'price': price,
                    'img': crop_img.name if crop_img else None
                })
                st.success('Crop listed for sale!')
    with tab_objs[9]:  # Selling Item
        st.header(t('market_selling_item', lang))
        if not st.session_state['market_logged_in_user']:
            st.warning('Please log in to view your listings.')
        else:
            user_listings = [l for l in st.session_state['market_listings'] if l['user'] == st.session_state['market_logged_in_user']['username']]
            if not user_listings:
                st.info('No crops listed for sale yet.')
            else:
                for l in user_listings:
                    st.write(f"Crop: {l['crop']} | Qty: {l['qty']} kg | Price: ‚Çπ{l['price']} per kg | Image: {l['img']}")

def analytics_dashboard_page():
    import json
    import os
    import pandas as pd
    import streamlit as st
    import matplotlib.pyplot as plt
    from collections import Counter
    from datetime import datetime

    lang = st.session_state['lang']
    st.title(t('analytics_dashboard', lang))
    st.markdown('---')

    # Load conversations
    conversations_path = "conversations.json"
    if not os.path.exists(conversations_path):
        st.warning(t('analytics_no_conversations', lang))
        return
    with open(conversations_path, "r") as f:
        all_convs = json.load(f)

    # Flatten all user/model messages
    chat_records = []
    for user_id, history in all_convs.items():
        for i, entry in enumerate(history):
            role = entry.get("role")
            parts = entry.get("parts", [])
            timestamp = entry.get("timestamp")
            for part in parts:
                chat_records.append({
                    "user_id": user_id,
                    "role": role,
                    "message": part,
                    "msg_idx": i,
                    "timestamp": timestamp
                })
    df = pd.DataFrame(chat_records)
    if df.empty:
        st.info(t('analytics_no_data', lang))
        return

    # Convert timestamp to datetime
    if 'timestamp' in df.columns:
        df['timestamp'] = pd.to_datetime(df['timestamp'], errors='coerce')
    else:
        df['timestamp'] = pd.NaT

    # 1. Total number of AgriBot chats/questions
    st.subheader(t('analytics_total_questions', lang))
    st.metric(t('analytics_total_questions', lang), df[(df['role'] == 'user')].shape[0])

    # 2. Most common crops discussed (simple keyword scan)
    st.subheader(t('analytics_common_crops', lang))
    crop_keywords = [
        "wheat", "rice", "maize", "soybean", "cotton", "sugarcane", "groundnut", "potato", "tomato", "onion", "chickpea", "mustard", "sorghum", "banana", "grapes", "mango", "pigeonpea", "sunflower", "pea"
    ]
    crop_counter = Counter()
    for msg in df[df['role'] == 'user']['message'].str.lower():
        for crop in crop_keywords:
            if crop in msg:
                crop_counter[crop] += 1
    if crop_counter:
        st.bar_chart(pd.DataFrame.from_dict(crop_counter, orient='index', columns=['Count']).sort_values('Count', ascending=False))
    else:
        st.write(t('analytics_no_keywords', lang))

    # 3. Disease diagnosis trends (scan for 'disease', 'blight', 'virus', etc.)
    st.subheader(t('analytics_disease_trends', lang))
    disease_keywords = ["disease", "blight", "virus", "rot", "spot", "mildew", "rust", "bacterial", "fungal", "deficiency"]
    disease_counter = Counter()
    for msg in df[df['role'] == 'user']['message'].str.lower():
        for d in disease_keywords:
            if d in msg:
                disease_counter[d] += 1
    if disease_counter:
        st.bar_chart(pd.DataFrame.from_dict(disease_counter, orient='index', columns=['Count']).sort_values('Count', ascending=False))
    else:
        st.write(t('analytics_no_disease', lang))

    # 4. User engagement over time (by day)
    st.subheader(t('analytics_engagement', lang) + " (by day)")
    if df['timestamp'].notnull().any():
        df['date'] = df['timestamp'].dt.date
        daily_counts = df[df['role'] == 'user'].groupby('date').size()
        st.line_chart(daily_counts)
    else:
        st.info("No timestamp data available for time-based trends.")

    # 5. Peak hours (hour of day)
    st.subheader("Peak Activity Hours (UTC)")
    if df['timestamp'].notnull().any():
        df['hour'] = df['timestamp'].dt.hour
        hour_counts = df[df['role'] == 'user'].groupby('hour').size()
        st.bar_chart(hour_counts)
    else:
        st.info("No timestamp data available for peak hour analysis.")

    # 6. Top users (by message count)
    st.subheader("Top Users (by message count)")
    top_users = df[df['role'] == 'user']['user_id'].value_counts().head(10)
    st.bar_chart(top_users)

    # 7. Average response length (user and bot)
    st.subheader("Average Response Length (words)")
    avg_user = df[df['role'] == 'user']['message'].str.split().str.len().mean()
    avg_bot = df[df['role'] == 'model']['message'].str.split().str.len().mean()
    st.write(f"User: {avg_user:.1f} words | AgriBot: {avg_bot:.1f} words")

    # 8. Pie chart of question types (disease, market, weather, etc.)
    st.subheader(t('analytics_pie_types', lang))
    type_keywords = {
        'disease': ["disease", "blight", "virus", "rot", "spot", "mildew", "rust", "bacterial", "fungal", "deficiency"],
        'market': ["market", "price", "sell", "buy", "msp", "cost"],
        'weather': ["weather", "rain", "temperature", "forecast", "humidity"],
        'fertilizer': ["fertilizer", "urea", "npk", "manure", "compost"],
        'other': []
    }
    type_counter = Counter()
    for msg in df[df['role'] == 'user']['message'].str.lower():
        found = False
        for ttype, keys in type_keywords.items():
            if any(k in msg for k in keys):
                type_counter[ttype] += 1
                found = True
                break
        if not found:
            type_counter['other'] += 1
    if type_counter:
        fig, ax = plt.subplots()
        ax.pie(list(type_counter.values()), labels=list(type_counter.keys()), autopct='%1.1f%%', startangle=90)
        ax.axis('equal')
        st.pyplot(fig)
    else:
        st.write(t('analytics_no_types', lang))

    # 9. Recent activity log
    st.subheader(t('analytics_recent_log', lang))
    st.dataframe(df.tail(10)[['user_id', 'role', 'message', 'timestamp']].iloc[::-1])

    # 10. Downloadable CSV
    st.subheader("Download Analytics Data")
    csv = df.to_csv(index=False)
    st.download_button("Download CSV", csv, "analytics_data.csv", "text/csv")

    # 11. CSV/statistics visualized (if you have other CSVs, you can add more here)
    st.markdown('---')
    st.info(t('analytics_info_upload', lang))
    uploaded_csv = st.file_uploader(t('analytics_upload_csv', lang), type=["csv"])
    if uploaded_csv:
        csv_df = pd.read_csv(uploaded_csv)
        st.write(csv_df.head())
        st.bar_chart(csv_df.select_dtypes(include=['number']))

def get_corpus_data_page():
    st.title('Get Corpus Data')
    st.markdown('You can download all collected user input data as a CSV file below:')
    if os.path.exists(USER_INPUT_LOG):
        import pandas as pd
        df = pd.read_csv(USER_INPUT_LOG)
        st.subheader('Preview of Collected User Input Data')
        st.dataframe(df.head(20))
        with open(USER_INPUT_LOG, 'rb') as f:
            st.download_button('Download CSV', f, file_name='user_input_log.csv', mime='text/csv')
    else:
        st.warning('No user input log found yet.')

# --- Main app logic ---
def main():
    if not st.session_state.get('logged_in', False):
        login_page()
        return
    init_session()
    sidebar_navigation()
    # Dataset paths
    base_dir = os.path.dirname(os.path.abspath(__file__))
    farmer_dataset_path = os.path.join(base_dir, "dataset_farming", "farmer_advisor_dataset.csv")
    market_dataset_path = os.path.join(base_dir, "dataset_farming", "market_researcher_dataset.csv")
    # Instantiate agents
    farmer_advisor = FarmerAdvisor(farmer_dataset_path)
    market_researcher = MarketResearcher(market_dataset_path)
    weather_module = WeatherModule(location="India")
    agri_expert = AgriculturalExpert()
    memory = MemoryManager()
    nlp_models = NLPModels()
    # Navigation
    page = st.session_state['page']
    if page == 'home':
        home_page()
    elif page == 'recommendations':
        recommendations_page(farmer_advisor, market_researcher, weather_module, agri_expert, memory)
    elif page == 'diagnosis':
        diagnosis_page()
    elif page == 'severity':
        severity_page()
    elif page == 'validation':
        validation_page()
    elif page == 'growth-diary':
        growth_diary_page()
    elif page == 'knowledge-sharing':
        knowledge_sharing_page()
    elif page == 'soil-health':
        soil_health_page()
    elif page == 'heatmaps':
        heatmaps_page()
    elif page == 'khet-market':
        khet_market_page()
    elif page == 'analytics-dashboard':
        analytics_dashboard_page()
    elif page == 'get-corpus-data':
        get_corpus_data_page()
    else:
        home_page()

if __name__ == "__main__":
    main()
